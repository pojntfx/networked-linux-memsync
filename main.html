<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Felicitas Pojtinger (Stuttgart Media University)" />
  <meta name="dcterms.date" content="2023-08-04" />
  <meta name="keywords" content="true" />
  <title>Efficient Synchronization of Linux Memory Regions over a Network: A Comparative Study and Implementation</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    div.abstract {
      margin: 2em 2em 2em 2em;
      text-align: left;
      font-size: 85%;
    }
    div.abstract-title {
      font-weight: bold;
      text-align: center;
      padding: 0;
      margin-bottom: 0.5em;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
    }
    .hanging div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Efficient Synchronization of Linux Memory Regions over
a Network: A Comparative Study and Implementation</h1>
<p class="subtitle">TODO: Add subtitle</p>
<p class="author">Felicitas Pojtinger (Stuttgart Media University)</p>
<p class="date">2023-08-04</p>
<div class="abstract">
<div class="abstract-title">Abstract</div>
<h2 id="section" class="unnumbered unlisted"></h2>
<p>TODO: Add abstract</p>
</div>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1.1</span>
Introduction</a></li>
<li><a href="#technology"><span class="toc-section-number">1.2</span>
Technology</a>
<ul>
<li><a href="#the-linux-kernel"><span class="toc-section-number">1.2.1</span> The Linux Kernel</a></li>
<li><a href="#linux-kernel-modules"><span class="toc-section-number">1.2.2</span> Linux Kernel Modules</a></li>
<li><a href="#unix-signals-and-handlers"><span class="toc-section-number">1.2.3</span> UNIX Signals and
Handlers</a></li>
<li><a href="#principle-of-locality"><span class="toc-section-number">1.2.4</span> Principle of Locality</a></li>
<li><a href="#memory-hierarchy"><span class="toc-section-number">1.2.5</span> Memory Hierarchy</a></li>
<li><a href="#memory-management-in-linux"><span class="toc-section-number">1.2.6</span> Memory Management in
Linux</a></li>
<li><a href="#swap-space"><span class="toc-section-number">1.2.7</span>
Swap Space</a></li>
<li><a href="#page-faults"><span class="toc-section-number">1.2.8</span>
Page Faults</a></li>
<li><a href="#mmap"><span class="toc-section-number">1.2.9</span>
<code>mmap</code></a></li>
<li><a href="#inotify"><span class="toc-section-number">1.2.10</span>
<code>inotify</code></a></li>
<li><a href="#linux-kernel-caching"><span class="toc-section-number">1.2.11</span> Linux Kernel Caching</a></li>
<li><a href="#tcp-udp-and-quic"><span class="toc-section-number">1.2.12</span> TCP, UDP and QUIC</a></li>
<li><a href="#delta-synchronization"><span class="toc-section-number">1.2.13</span> Delta Synchronization</a></li>
<li><a href="#file-systems-in-userspace-fuse"><span class="toc-section-number">1.2.14</span> File Systems In Userspace
(FUSE)</a></li>
<li><a href="#network-block-device-nbd"><span class="toc-section-number">1.2.15</span> Network Block Device
(NBD)</a></li>
<li><a href="#virtual-machine-live-migration"><span class="toc-section-number">1.2.16</span> Virtual Machine Live
Migration</a></li>
<li><a href="#streams-and-pipelines"><span class="toc-section-number">1.2.17</span> Streams and Pipelines</a></li>
<li><a href="#grpc"><span class="toc-section-number">1.2.18</span>
gRPC</a></li>
<li><a href="#redis"><span class="toc-section-number">1.2.19</span>
Redis</a></li>
<li><a href="#s3-and-minio"><span class="toc-section-number">1.2.20</span> S3 and Minio</a></li>
<li><a href="#cassandra-and-scyllladb"><span class="toc-section-number">1.2.21</span> Cassandra and
ScylllaDB</a></li>
</ul></li>
<li><a href="#planning"><span class="toc-section-number">1.3</span>
Planning</a>
<ul>
<li><a href="#pull-based-synchronization-with-userfaultfd"><span class="toc-section-number">1.3.1</span> Pull-Based Synchronization With
<code>userfaultfd</code></a></li>
<li><a href="#push-based-synchronization-with-mmap-and-hashing"><span class="toc-section-number">1.3.2</span> Push-Based Synchronization With
<code>mmap</code> and Hashing</a></li>
<li><a href="#push-pull-synchronization-with-fuse"><span class="toc-section-number">1.3.3</span> Push-Pull Synchronization with
FUSE</a></li>
<li><a href="#mounts-with-nbd"><span class="toc-section-number">1.3.4</span> Mounts with NBD</a></li>
<li><a href="#push-pull-synchronization-with-mounts"><span class="toc-section-number">1.3.5</span> Push-Pull Synchronization with
Mounts</a></li>
<li><a href="#pull-based-synchronization-with-migrations"><span class="toc-section-number">1.3.6</span> Pull-Based Synchronization with
Migrations</a></li>
</ul></li>
<li><a href="#implementation"><span class="toc-section-number">1.4</span> Implementation</a>
<ul>
<li><a href="#userfaults-in-go-with-userfaultfd"><span class="toc-section-number">1.4.1</span> Userfaults in Go with
<code>userfaultfd</code></a></li>
<li><a href="#file-based-synchronization"><span class="toc-section-number">1.4.2</span> File-Based
Synchronization</a></li>
<li><a href="#fuse-implementation-in-go"><span class="toc-section-number">1.4.3</span> FUSE Implementation in
Go</a></li>
<li><a href="#nbd-with-go-nbd"><span class="toc-section-number">1.4.4</span> NBD with
<code>go-nbd</code></a></li>
<li><a href="#managed-mounts-with-r3map"><span class="toc-section-number">1.4.5</span> Managed Mounts with
r3map</a></li>
<li><a href="#live-migration"><span class="toc-section-number">1.4.6</span> Live Migration</a></li>
<li><a href="#pluggable-encryption-authentication-and-transport"><span class="toc-section-number">1.4.7</span> Pluggable Encryption,
Authentication and Transport</a></li>
<li><a href="#concurrent-backends"><span class="toc-section-number">1.4.8</span> Concurrent Backends</a></li>
<li><a href="#remote-stores-as-backends"><span class="toc-section-number">1.4.9</span> Remote Stores as
Backends</a></li>
<li><a href="#concurrent-bi-directional-rpcs-with-dudirekta"><span class="toc-section-number">1.4.10</span> Concurrent Bi-Directional RPCs
with Dudirekta</a></li>
<li><a href="#connection-pooling-with-grpc"><span class="toc-section-number">1.4.11</span> Connection Pooling with
gRPC</a></li>
<li><a href="#optimizing-throughput-with-frpc"><span class="toc-section-number">1.4.12</span> Optimizing Throughput with
fRPC</a></li>
</ul></li>
<li><a href="#results"><span class="toc-section-number">1.5</span>
Results</a></li>
<li><a href="#discussion"><span class="toc-section-number">1.6</span>
Discussion</a>
<ul>
<li><a href="#remote-swap-with-ram-dl"><span class="toc-section-number">1.6.1</span> Remote Swap with
<code>ram-dl</code></a></li>
<li><a href="#mapping-tape-into-memory-with-tapisk"><span class="toc-section-number">1.6.2</span> Mapping Tape Into Memory With
<code>tapisk</code></a></li>
<li><a href="#improving-cloud-storage-clients"><span class="toc-section-number">1.6.3</span> Improving Cloud Storage
Clients</a></li>
<li><a href="#universal-database-media-and-asset-streaming"><span class="toc-section-number">1.6.4</span> Universal Database, Media and
Asset Streaming</a></li>
<li><a href="#universal-app-state-mounts-and-migrations"><span class="toc-section-number">1.6.5</span> Universal App State Mounts and
Migrations</a></li>
</ul></li>
</ul>
</nav>
<section id="introduction" data-number="0.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span>
Introduction</h2>
<p>TODO: Add introduction</p>
</section>
<section id="technology" data-number="0.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span>
Technology</h2>
<section id="the-linux-kernel" data-number="0.2.1">
<h3 data-number="1.2.1"><span class="header-section-number">1.2.1</span>
The Linux Kernel</h3>
<p>The open-source Linux kernel, was created by Linus Torvalds in 1991.
Developed primarily in the C programming language, it has recently seen
the addition of Rust as an approved language for further expansion and
development, esp. of drivers<span class="citation" data-cites="linux2023docs">[1]</span>. The powers millions of devices
across the globe, including servers, desktop computers, mobile phones,
and embedded devices. It serves as an intermediary between hardware and
applications, as an abstraction layer that simplifies the interaction
between them. It is engineered for compatibility with a wide array of
architectures, such as ARM, x86, RISC-V, and others.</p>
<p>The kernel does not function as a standalone operating system. This
role is fulfilled by distributions, which build upon the Linux kernel to
create fully-fledged operating systems<span class="citation" data-cites="love2010linux">[2]</span>. Distributions supplement the
kernel with additional userspace tools, examples being GNU coreutils or
BusyBox. Depending on their target audience, they further enhance
functionality by integrating desktop environments and other
software.</p>
<p>The open-source nature of the Linux kernel makes it especially
interesting for academic exploration and usage. It offers transparency,
allowing anyone to inspect the source code in depth. Furthermore, it
encourages collaboration by enabling anyone to modify and contribute to
the source code. This transparency, coupled with the potential for
customization and improvement, makes developing for the Linux kernel a
good choice for this thesis.</p>
</section>
<section id="linux-kernel-modules" data-number="0.2.2">
<h3 data-number="1.2.2"><span class="header-section-number">1.2.2</span>
Linux Kernel Modules</h3>
<p>Linux is a extensible, but not a microkernel. Despite it’s monolithic
nature, it allows for the integration of kernel modules<span class="citation" data-cites="love2010linux">[2]</span>. Kernel modules
are small pieces of kernel-level code that can be dynamically
incorporated into the kernel, presenting the advantage of extending
kernel functionality without necessitating system reboots.</p>
<p>The dynamism of these modules comes from their ability to be loaded
and unloaded into the running kernel as per user needs. This
functionality aids in keeping the kernel size both manageable and
maintainable, thereby promoting efficiency. Kernel modules are
traditionally developed using the C programming language, like the
kernel itself, ensuring compatibility and consistent performance.</p>
<p>Kernel modules interact with the kernel via APIs (Application
Programming Interfaces). Despite their utility, since they run in kernel
space, modules do carry a potential risk. If not written with careful
attention to detail, they can introduce significant instability into the
kernel, negatively affecting the overall system performance and
reliability.</p>
<p>Modules can be managed and controlled at different stages, starting
from boot time, and be manipulated dynamically when the system is
already running. This is facilitated by utilities like
<code>modprobe</code> and <code>rmmod</code><span class="citation" data-cites="maurer2008professional">[3]</span>.</p>
<p>In the lifecycle of a kernel module, two key functions are of
significance: initialization and cleanup. The initialization function is
responsible for setting up the module when it’s loaded into the kernel.
Conversely, the cleanup function is used to safely remove the module
from the kernel, freeing up any resources it previously consumed. These
lifecycle functions, along with other such hooks, provide a more
structured approach to module development.</p>
</section>
<section id="unix-signals-and-handlers" data-number="0.2.3">
<h3 data-number="1.2.3"><span class="header-section-number">1.2.3</span>
UNIX Signals and Handlers</h3>
<p>UNIX signals are an integral component of UNIX-like systems,
including Linux. They function as software interrupts, notifying a
process of significant occurrences, such as exceptions. Signals may be
generated from various sources, including the kernel, user input, or
other processes, making them a versatile tool for inter-process
notifications.</p>
<p>Aside from this notification role, signals also serve as an
asynchronous communication mechanism between processes or between the
kernel and a process. As such, they have an inherent ability to deliver
important notifications without requiring the recipient process to be in
a specific state of readiness<span class="citation" data-cites="stevens2000advanced">[4]</span>. Each signal has a default
action associated with it, the most common of which are terminating the
process or simply ignoring the signal.</p>
<p>To customize how a process should react upon receiving a specific
signal, handlers can be utilized. Handlers dictate the course of action
a process should take when a signal is received. Using the
<code>sigaction()</code> function, a handler can be installed for a
specific signal, enabling a custom response to that signal such as
reloading configuration, cleaning up ressources before exiting or
enabling verbose logging <span class="citation" data-cites="robbins2003unix">[5]</span>.</p>
<p>It is however important to note that signals are not typically
utilized as a primary inter-process communication (IPC) mechanism. This
is primarily due to their limitation in carrying additional data. While
signals effectively alert a process of an event, they are not designed
to convey forther information related to that event; consequently, they
are best used in scenarios where simple event-based notifications are
sufficient, rather than for more complex data exchange requirements.</p>
</section>
<section id="principle-of-locality" data-number="0.2.4">
<h3 data-number="1.2.4"><span class="header-section-number">1.2.4</span>
Principle of Locality</h3>
<p>The principle of locality, or locality of reference, refers to the
tendency of a processor in a computer system to recurrently access the
same set of memory locations within a brief span of time. This principle
forms the basis of a predictable pattern of behavior that is evident
across computer systems, and can be divided into two distinct types:
temporal locality and spatial locality<span class="citation" data-cites="stallings2010architecture">[6]</span>.</p>
<p>Temporal locality revolves around the frequent use of particular data
within a limited time period. Essentially, if a memory location is
accessed once, it is probable that this same location will be accessed
again in the near future. To leverage this pattern and improve
performance, computer systems are designed to maintain a copy of this
frequently accessed data in a faster memory storage, which in turn,
significantly reduces the latency in subsequent references.</p>
<p>Spatial locality, on the other hand, refers to the use of data
elements that are stored in nearby locations. That is, once a particular
memory location is accessed, the system assumes that other nearby
locations are also likely to be accessed shortly. Therefore, to optimize
performance, the system tries to anticipate these subsequent accesses by
preparing for faster access to these nearby memory locations. Temporal
locality is considered a unique instance of spatial locality,
demonstrating how the two types are closely interlinked.</p>
<p>A specific instance of spatial locality, termed sequential locality,
occurs when the data elements are organized and accessed in a linear
sequence. An example of this is when elements in a one-dimensional array
are traversed systematically, accessing the elements one by one in their
sequential order.</p>
<p>Locality of reference can be instrumental in improving the overall
performance of a system. To achieve this, a variety of optimization
techniques are deployed, such as caching, which stores copies of
frequently accessed data in quick-access memory, and prefetching for
memory, which involves loading potential future data into cache before
it’s actually needed.</p>
</section>
<section id="memory-hierarchy" data-number="0.2.5">
<h3 data-number="1.2.5"><span class="header-section-number">1.2.5</span>
Memory Hierarchy</h3>
<p>The memory hierarchy in computers is an organized structure based on
factors such as size, speed, cost, and proximity to the Central
Processing Unit (CPU). It follows the principle of locality, which
suggests that data and instructions that are accessed frequently should
be stored as close to the CPU as possible<span class="citation" data-cites="smith1982cache">[7]</span>. This principle is crucial
primarily due to the limitations of “the speed of the cable”, where both
throughput and latency decrease as distance increases due to factors
like signal dampening and the finite speed of light.</p>
<p>TODO: Add graphic of the memory hierarchy</p>
<p>At the top of the hierarchy are registers, which are closest to the
CPU. They offer very high speed, but provide limited storage space,
typically accommodating 32-64 bits of data. These registers are used by
the CPU to perform operations.</p>
<p>Following registers in the hierarchy is cache memory, typically
divided into L1, L2, and L3 levels. As the level increases, each layer
becomes larger and less expensive. Cache memory serves as a buffer for
frequently accessed data, with predictive algorithms typically
optimizing its usage.</p>
<p>Main Memory, i.e. Random Access Memory (RAM), provides larger storage
capacity than cache but operates at a slower speed. It typically stores
running programs and open files.</p>
<p>Below main memory, we find secondary storage devices such as Solid
State Drives (SSD) or Hard Disk Drives (HDD). Although slower than RAM,
these devices can store larger amounts of data and typically contain the
operating system and application binary fies. Importantly, they are
persistent, meaning they retain data even after power is cut.</p>
<p>Tertiary storage, including optical disks and tape, is slow but very
cost-effective. Tape storage can store very large amounts of data for
long periods of time. These types of storage are typically used for
archiving or physically transporting data, such as importing data from
personal infrastructure to a service like AWS<span class="citation" data-cites="barr2021offline">[8]</span>.</p>
<p>The memory hierarchy is not static but evolves with technological
advancements, leading to some blurring of these distinct layers<span class="citation" data-cites="maruf2023memory">[9]</span>. For instance,
Non-Volatile Memory Express (NVMe) storage technologies can rival the
speed of RAM while offering greater storage capacities. Similarly, some
research, such as the work presented in this thesis, further challenges
traditional hierarchies by exposing tertiary or secondary storage with
the same interface as main memory.</p>
</section>
<section id="memory-management-in-linux" data-number="0.2.6">
<h3 data-number="1.2.6"><span class="header-section-number">1.2.6</span>
Memory Management in Linux</h3>
<p>Memory management forms a cornerstone of any operating system,
serving as a critical buffer between applications and physical memory.
Arguably, it can be considered one of the fundamental purposes of an
operating system itself. This system helps maintain system stability and
provides security guarantees, such as ensuring that only a specific
process can access its allocated memory.</p>
<p>Within the context of the Linux operating system, memory management
is divided into two major segments: kernel space and user space.</p>
<p>Kernel space is where the kernel itself and kernel modules operate.
The kernel memory module is responsible for managing this segment. Slab
allocation is a technique employed in kernel space management; this
technique groups objects of the same size into caches, enhancing memory
allocation speed and reducing fragmentation of memory<span class="citation" data-cites="bonwick1994slaballoc">[10]</span>.</p>
<p>User space is the memory segment where applications and certain
drivers store their memory<span class="citation" data-cites="gorman2004linuxmem">[11]</span>. User space memory
management involves a paging system, offering each application its
unique private virtual address space.</p>
<p>This virtual address space is divided into units known as pages, each
typically 4 KB in size. These pages can be mapped to any location in
physical memory, providing flexibility and optimizing memory
utilization. The use of this virtual address space further adds a layer
of abstraction between the application and the physical memory,
enhancing the security and isolation of processes.</p>
</section>
<section id="swap-space" data-number="0.2.7">
<h3 data-number="1.2.7"><span class="header-section-number">1.2.7</span>
Swap Space</h3>
<p>Swap space refers to a designated portion of the secondary storage
utilized as virtual memory in a computer system<span class="citation" data-cites="gorman2004linuxmem">[11]</span>. This feature plays a
crucial role in systems that run multiple applications simultaneously.
When memory resources are strained, swap space comes into play,
relocating inactive parts of the RAM to secondary storage. This action
frees up space in primary memory for other processes, enabling smoother
operation and preventing a potential system crash.</p>
<p>In the case of Linux, swap space implementation aligns with a demand
paging system. This means that memory is allocated only when required.
The swap space in Linux can be a swap partition, which is a distinct
area within the secondary storage, or it can take the form of a swap
file, which is a standard file that can be expanded or truncated based
on need. The usage of swap partitions and files is transparent to the
user.</p>
<p>The Linux kernel employs a Least Recently Used (LRU) algorithm to
determine which memory pages should be moved to swap space. This
algorithm effectively prioritizes pages based on their usage,
transferring those that have not been recently used to swap space.</p>
<p>Swap space also plays a significant role in system hibernation.
Before the system enters hibernation, the content of RAM is stored in
the swap space, where it remains persistent even without power. When the
system is resumed, the memory content is read back from swap space,
restoring the system to its pre-hibernation state<span class="citation" data-cites="kernel2023suspend">[12]</span>.</p>
<p>However, the use of swap space can impact system performance. Since
secondary storage devices are usually slower than primary memory, heavy
reliance on swap space can cause significant system slowdowns. To
mitigate this, Linux allows for the adjustment of “swappiness”, a
parameter that controls the system’s propensity to swap memory pages.
Adjusting this setting can balance the use of swap space to maintain
system performance while still preserving the benefits of virtual memory
management.</p>
</section>
<section id="page-faults" data-number="0.2.8">
<h3 data-number="1.2.8"><span class="header-section-number">1.2.8</span>
Page Faults</h3>
<p>Page faults are instances in which a process attempts to access a
page that is not currently available in primary memory. This situation
triggers the operating system to swap the necessary page from secondary
storage into primary memory. These are significant events in memory
management, as they determine how efficiently an operating system
utilizes its resources.</p>
<p>Page faults can be broadly categorized into two types: minor and
major. Minor page faults occur when the desired page resides in memory
but isn’t linked to the process that requires it. On the other hand, a
major page fault takes place when the page has to be loaded from
secondary storage, a process that typically takes more time and
resources<span class="citation" data-cites="maurer2008professional">[3]</span>.</p>
<p>To minimize the occurrence of page faults, memory management
algorithms such as the afore-mentioned Least Recently Used (LRU) and the
more straightforward clock algorithm are often employed. These
algorithms effectively manage the order and priority of memory pages,
helping to ensure that frequently used pages are readily available in
primary memory.</p>
<p>Handling page faults involves certain techniques to ensure smooth
operation. One such technique is prefetching, which anticipates future
page requests and proactively loads these pages into memory. Another
approach involves page compression, where inactive pages are compressed
and stored in memory preemptively<span class="citation" data-cites="silberschatz2018operating">[13]</span>. This reduces the
likelihood of major page faults by conserving memory space, allowing
more pages to reside in primary memory.</p>
<p>In general, handling page faults is a task delegated to the kernel.
This critical balance between resource availability and system
performance is part of the kernel’s memory management duties, ensuring
that processes can access the pages they require while maintaining
efficient use of system memory.</p>
</section>
<section id="mmap" data-number="0.2.9">
<h3 data-number="1.2.9"><span class="header-section-number">1.2.9</span>
<code>mmap</code></h3>
<p><code>mmap</code> is a versatile UNIX system call, used for mapping
files or devices into memory, enabling a variety of core tasks like
shared memory, file I/O, and fine-grained memory allocation. Due to its
powerful nature, it is commonly harnessed in applications like
databases.</p>
<p>One standout feature of <code>mmap</code> is its ability to create
what is essentially a direct memory mapping between a file and a region
of memory<span class="citation" data-cites="choi2017mmap">[14]</span>.
This connection means that read operations performed on the mapped
memory region directly correspond to reading the file and vice versa,
enhancing efficiency by reducing the overhead as the necessity for
context switches (compared to i.e. the <code>read</code> or
<code>write</code> system calls) diminishes.</p>
<p>The key advantage that <code>mmap</code> provides is the capacity to
facilitate zero-copy operations. In practical terms, this signifies data
can be accessed directly as if it were positioned in memory, eliminating
the need to copy it from the disk first. This direct memory access saves
time and reduces processing requirements, offering substantial
performance improvements.</p>
<p><code>mmap</code> is also proficient in sharing memory between
processes without having to pass through the kernel with system
calls<span class="citation" data-cites="stevens2000advanced">[4]</span>.
With this feature, <code>mmap</code> can create shared memory spaces
where multiple processes can read and write, enhancing interprocess
communication and data transfer efficiency.</p>
<p>The potential speed improvement does however come with a notable
drawback: It bypasses the file system cache, which can potentially
result in stale data when multiple processes are reading and writing
simultaneously. This bypass may lead to a scenario where one process
modifies data in the <code>mmap</code> region, and another process that
is not monitoring for changes might remain unaware and continue to work
with outdated data.</p>
</section>
<section id="inotify" data-number="0.2.10">
<h3 data-number="1.2.10"><span class="header-section-number">1.2.10</span> <code>inotify</code></h3>
<p>The <code>inotify</code> is an event-driven notification system of
the Linux kernel, designed to monitor the file system for different
events, such as modifications and accesses, among others<span class="citation" data-cites="prokop2010inotify">[15]</span>. Its
particularly useful because it can be configured to watch only write
operations on certain files, i.e. only <code>write</code> operations.
This level of control can offer considerable benefits in cases where
there is a need to focus system resources on certain file system events,
and not on others.</p>
<p>Naturally, <code>inotify</code> comes with some recognizable
advantages. Significantly, it diminishes overhead and resource use when
compared to polling strategies. Polling is an operation-heavy approach
as it continuously checks the status of the file system, regardless of
whether any changes have occurred. In contrast, <code>inotify</code>
works in a more event-driven way, where it only takes action when a
specific event actually occurs. This is usually more efficient, reducing
overhead especially where there are infrequent changes to the file
system.</p>
<p>Thanks to its efficiency and flexibility, <code>inotify</code> has
found its utilization across many applications, especially in file
synchronization services. In this usecase, the ability to instantly
notify the system of file changes aids in instant synchronization of
files, demonstrating how critical its role can be in real-time or near
real-time systems that are dependent on keeping data up-to-date.</p>
<p>However, as is the case with many system calls, there is a limit to
its scalability. <code>inotify</code> is constrained by a limit on how
many watches can be established. This limitation can pose challenges in
intricate systems where there is a high quantity of files or directories
to watch for, and might warrant additional management or fallback to
heavier polling mechanisms for some parts of the system.</p>
</section>
<section id="linux-kernel-caching" data-number="0.2.11">
<h3 data-number="1.2.11"><span class="header-section-number">1.2.11</span> Linux Kernel Caching</h3>
<p>Caching is a key feature of the Linux kernel that work to boost
efficiency and performance. Within this framework, there are two broad
categories: disk caching and file caching.</p>
<p>Disk caching in Linux is a strategic method that temporarily stores
frequently accessed data in RAM. It is implemented through the page
cache subsystem, and operates under the assumption that data situated
near data that has already been accessed will be needed soon. By
retaining data close to the CPU where it may be swiftly accessed without
costly disk reads can greatly reduce overall access time. The data
within the cache is also managed using the LRU algorithm, which prunes
the least recently used items first when space is needed.</p>
<p>Linux also caches file system metadata in specialized structures
known as the <code>dentry</code> and <code>inode</code> caches. This
metadata encompasses varied information such as file names, attributes,
and locations. The key benefit of this is that it expedites the
resolution of path names and file attributes, such as tracking when
files were last changed for polling. Notably, file read/write operations
are also channeled through the disk cache, further illustrating the
intricate interconnectedness of disk and file caching mechanisms in the
Linux Kernel.</p>
<p>While such caching mechanisms can improve performance, they also
introduce complexities. One such complexity involves maintaining data
consistency between the disk and cache through the process known as
writebacks; aggressive writebacks, where data is copied back to disk
frequently, can lead to reduced performance, while excessive delays may
risk data loss if the system crashes before data has been saved.</p>
<p>Another complexity arises from the necessity to release cached data
under memory pressure, known as cache eviction. This requires
sophisticated algorithms, such as LRU, to ensure effective utilization
of available cache space<span class="citation" data-cites="maurer2008professional">[3]</span>. Prioritizing what to
keep in cache when memory pressure builds does directly impact the
overall system performance.</p>
</section>
<section id="tcp-udp-and-quic" data-number="0.2.12">
<h3 data-number="1.2.12"><span class="header-section-number">1.2.12</span> TCP, UDP and QUIC</h3>
<p>TCP (Transmission Control Protocol), UDP (User Datagram Protocol),
and QUIC (Quick UDP Internet Connections) are three key communication
protocols utilized in the internet today.</p>
<p>TCP has long been the reliable backbone for internet communication
due to its connection-oriented nature <span class="citation" data-cites="postel1981tcp">[16]</span>. It ensures the guaranteed
delivery of data packets and their correct order, rendering it a highly
dependable means for data transmission. Significantly, TCP incorporates
error checking, allowing the detection and subsequent retransmission of
lost packets. TCP also includes a congestion control mechanism to manage
data transmission seamlessly during high traffic. Due to to these
features and it’s long legacy, TCP is widely used to power the majority
of the web where reliable, ordered, and error-checked data transmission
is required.</p>
<p>UDP is a connectionless protocol that does not make the same
guarantees about the reliability or ordered delivery of data packets
<span class="citation" data-cites="postel1980udp">[17]</span>. This
lends UDP a speed advantage over TCP, resulting in less communication
overhead. Although it lacks TCP’s robustness in handling errors and
maintaining data order, UDP finds use in applications where speed and
latency take precedence over reliability. This includes online gaming,
video calls, and other real-time communication modes where quick data
transmission is crucial even if temporary packet loss occurs.</p>
<p>QUIC, a modern UDP-base transport layer protocol, was originally
created by Google and standardized by the IETF in 2021<span class="citation" data-cites="rfc2021quic">[18]</span>. It aspires to
combine the best qualities of TCP and UDP <span class="citation" data-cites="langley2017quic">[19]</span>. Unlike raw UDP, QUIC ensures
the reliability of data transmission and guarantees the ordered delivery
of data packets similarly to TCP, while intending to keep UDP’s speed
advantages. One of QUIC’s standout features is its ability to reduce
connection establishment times, which effectively lowers initial
latency. It achieves this by merging the typically separate connection
and security handshakes, reducing the time taken for a connection to be
established. Additionally, QUIC is designed to prevent the issue of
“head-of-line blocking”, allowing for the independent delivery of
separate data streams. This means it can handle the delivery of separate
data streams without one stream blocking another, resulting in smoother
and more efficient transmission, a feature which is especially important
for applications with lots of concurrent transmissions.</p>
</section>
<section id="delta-synchronization" data-number="0.2.13">
<h3 data-number="1.2.13"><span class="header-section-number">1.2.13</span> Delta Synchronization</h3>
<p>Delta synchronization is a technique that allows for efficient
synchronization of files between hosts, aiming to transfer only those
parts of the file that have undergone changes instead of the entire file
in order to reduce network and I/O overhead. Perhaps the most recognized
tool employing this method of synchronization is <code>rsync</code>, an
open-source data synchronization utility in Unix-like operating
systems<span class="citation" data-cites="xiao2018rsync">[20]</span>.</p>
<p>TODO: Add sequence diagram of the delta sync protocol from
https://blog.acolyer.org/2018/03/02/towards-web-based-delta-synchronization-for-cloud-storage-systems/</p>
<p>While there are many applications of such an algorithm, it typically
starts on file block division, dissecting the file on the destination
side into fixed-size blocks. For each of these blocks, a quick albeit
weak checksum calculation is performed, and these checksums are
transferred to the source system.</p>
<p>The source initiates the same checksum calculation process. These
checksums are then compared to those received from the destination
(matching block identification). The outcome of this comparison allows
the source to detect the blocks which have transformed since the last
synchronization.</p>
<p>Once the altered blocks are identified, the source proceeds to send
the offset of each block alongside the data of the changed block to the
destination. Upon receiving a block, the destination writes it to the
specific offset in the file. This process results in the reconstruction
of the file in accordance with the modifications undertaken at the
source, after which the next synchronization cycle can start.</p>
</section>
<section id="file-systems-in-userspace-fuse" data-number="0.2.14">
<h3 data-number="1.2.14"><span class="header-section-number">1.2.14</span> File Systems In Userspace
(FUSE)</h3>
<p>File Systems in Userspace (FUSE) is a software interface that enables
the creation of custom file systems in the userspace, as opposed to
developing them as kernel modules. This reduces the need for the
low-level kernel development skills that are usually associated with
creating new file systems.</p>
<p>The FUSE APIs are available on various platforms; though mostly
deployed on Linux, it can also be found on macOS and FreeBSD. In FUSE, a
userspace program registers itself with the FUSE kernel module and
provides callbacks for the file system operations. A simple read-only
FUSE can for example implement the following callbacks:</p>
<p>The <code>getattr</code> function is responsible for getting the
attributes of a file. For a real file system, this would include things
like the file’s size, its permissions, when it was last accessed or
modified, and so forth:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> example_getattr<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>path<span class="op">,</span> <span class="kw">struct</span> stat <span class="op">*</span>stbuf<span class="op">,</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">struct</span> fuse_file_info <span class="op">*</span>fi<span class="op">);</span></span></code></pre></div>
<p>The <code>readdir</code> function is used when a process wants to
list the files in a directory. It’s responsible for filling in the
entries for that directory:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> example_readdir<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>path<span class="op">,</span> <span class="dt">void</span> <span class="op">*</span>buf<span class="op">,</span> fuse_fill_dir_t filler<span class="op">,</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                         off_t offset<span class="op">,</span> <span class="kw">struct</span> fuse_file_info <span class="op">*</span>fi<span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">enum</span> fuse_readdir_flags flags<span class="op">);</span></span></code></pre></div>
<p>The <code>open</code> function is called when a process opens a file.
It’s responsible for checking that the operation is permitted (i.e. the
file exists and the process has the necessary permissions), and for
doing any necessary setup:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> example_open<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>path<span class="op">,</span> <span class="kw">struct</span> fuse_file_info <span class="op">*</span>fi<span class="op">);</span></span></code></pre></div>
<p>Finally, the <code>read</code> function is used when a process wants
to read data from a file. It’s responsible for copying the requested
data into the provided buffer:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">static</span> <span class="dt">int</span> example_read<span class="op">(</span><span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>path<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>buf<span class="op">,</span> <span class="dt">size_t</span> size<span class="op">,</span> off_t offset<span class="op">,</span> <span class="kw">struct</span> fuse_file_info <span class="op">*</span>fi<span class="op">);</span></span></code></pre></div>
<p>These callbacks would then be added to the FUSE operations struct and
passed to <code>fuse_main</code>, which takes care of registering the
operations with the FUSE kernel module and mounts the FUSE to a
directory. Similarly to this, callbacks for handling writes etc. can be
provided to the operation struct for a read-write capable FUSE<span class="citation" data-cites="libfuse2020example">[21]</span>.</p>
<p>When a user then performs a file system operation on a mounted FUSE
file system, the kernel module sends a request for executing that
operation to the userspace program. This is followed by the userspace
program returning a response, which the FUSE kernel module conveys back
to the user. As such, FUSE circumvents the complexity of coding the file
system implementation directly in the kernel. This approach enhances
safety, preventing entire kernel crashes due to errors within the
implementation being limited to user instead of kernel space.</p>
<p>TODO: Add graphic from
https://en.wikipedia.org/wiki/Filesystem_in_Userspace#/media/File:FUSE_structure.svg</p>
<p>Another benefit of a file system implemented as a FUSE is its
inherent portability. Unlike a file system created as a kernel module,
its interaction with the FUSE module rather than the kernel itself
creates a stronger contract between the two, and allows shipping the
file system as a plain binary instead of a binary kernel module, which
typically need to be built from source on the target machine unless they
are vendored by a distribution. Despite these benefits of FUSE, there is
a noticeable performance overhead associated with it. This is largely
due to the context switching between the kernel and the userspace that
occurs during its operation<span class="citation" data-cites="vangoor2017fuse">[22]</span>.</p>
<p>Today, FUSE is widely utilized to mount high-level external services
as file systems. For instance, it can be used to mount remote AWS S3
buckets with <code>s3fs</code><span class="citation" data-cites="gaul2023s3fs">[23]</span> or to mount a remote system’s disk
via Secure Shell (SSH) with SSHFS <span class="citation" data-cites="libfuse2022sshfs">[24]</span>.</p>
</section>
<section id="network-block-device-nbd" data-number="0.2.15">
<h3 data-number="1.2.15"><span class="header-section-number">1.2.15</span> Network Block Device
(NBD)</h3>
<p>Network Block Device (NBD) is a protocol for connecting to a remote
Linux block device. It typically works by communicating between a user
space-provided server and a Kernel-provided client. Though potentially
deployable over Wide Area Networks (WAN), it is primarily designed for
Local Area Networks (LAN) or localhost usage. The protocol is divided
into two phases: the handshake and the transmission<span class="citation" data-cites="blake2023nbd">[25]</span>.</p>
<p>TODO: Add sequence diagram of the NBD protocol</p>
<p>The NBD protocol involves multiple participants, notably one or
several clients, a server, and the concept of an export. It starts with
a client establishing a connection with the server. The server
reciprocates by delivering a greeting message highlighting various
server flags. The client responds by transmitting its own flags along
with the name of an export to use; a single NBD server can expose
multiple devices.</p>
<p>After receiving this, the server sends the size of the export and
other metadata. The client acknowledges this data, completing the
handshake. Post handshake, the client and server exchange commands and
replies. A command can correspond to any of the basic actions needed to
access a block device, for instance read, write or flush. These commands
might also contain data such as a chunk for writing, offsets, and
lengths among other elements. Replies may contain error messages,
success status, or data contingent on the reply type.</p>
<p>While powerful in many regards, NBD has some limitations. Its maximum
message size is capped at 32 MB<span class="citation" data-cites="clements2013nbd">[26]</span>, and the maximum block or chunk
size supported by the Kernel’s NBD client is a mere 4KB<span class="citation" data-cites="verhelst2023nbdclient">[27]</span>. Thus,
it might not be the most optimal protocol for WAN usage, especially in
scenarios with high latency.</p>
<p>NBD, being a protocol with a long legacy, comes with its own set of
operational quirks such as multiple different handshake versions and
legacy features. As a result, it is advisable to only implement the
latest recommended versions and the foundational feature set when
considering it NBD for a narrow usecase.</p>
<p>Despite the simplicity of the protocol, there are certain scenarios
where NBD falls short. Compared to FUSE, it has limitations when dealing
with backing devices that operate drastically different from
random-access storage devices like a tape drive, since it lacks the
ability to work with high-level abstractions such as files or
directories. For example, it does not support shared access to the same
file for multiple clients. However, this shortcoming can be considered
as an advantage for narrow usecases like memory synchronization, given
that it operates on a block level, where such features are not needed or
implemented at a higher layer.</p>
</section>
<section id="virtual-machine-live-migration" data-number="0.2.16">
<h3 data-number="1.2.16"><span class="header-section-number">1.2.16</span> Virtual Machine Live
Migration</h3>
<p>Virtual machine live migration involves the shifting of a virtual
machine, its state, and its connected devices from one host to another,
with the objective to minimize disrupted service by minimizing downtime
during data transfer processes.</p>
<p>Algorithms that intent to implement this usecase can be categorized
into two broad types: pre-copy migration and post-copy migration.</p>
<section id="pre-copy" data-number="0.2.16.1">
<h4 data-number="1.2.16.1"><span class="header-section-number">1.2.16.1</span> Pre-Copy</h4>
<p>The primary characteristic of pre-copy migration is its
“run-while-copy” nature, meaning that the copying of data from the
source to the destination occurs concurrently while the VM continues to
operate. This method is also applicable in a generic migration context
where an application or another data state is being updated.</p>
<p>In the case of a VM, the pre-copy migration procedure starts with
transfering the initial state of VM’s memory to the destination host.
During this operation, if modifications occur to any chunks of data,
they are flagged as “dirty”. These modified or “dirty” chunks of data
are then transferred to the destination until only a small number remain
- an amount small enough to stay within the allowable maximum downtime
criteria.</p>
<p>Following this, the VM is suspended at the source, enabling the
synchronization of the remaining chunks of data to the destination
without having to continue tracking dirty chunks. Once this
synchronization process is completed, the VM is resumed at the
destination host.</p>
<p>The pre-copy migration process is fairly robust, especially in
instances where there might be network disruption during
synchronization. This is because of fact that, at any given point during
migration, the VM is readily available in full either at the source or
the destination. A limitation to the approach however is that, if the VM
or application alters too many chunks on the source during migration, it
may not be possible to meet the maximum acceptable downtime criteria.
Maximum permissible downtime is also inherently restricted by the
available round-trip time (RTT)<span class="citation" data-cites="he2016migration">[28]</span>.</p>
</section>
<section id="post-copy" data-number="0.2.16.2">
<h4 data-number="1.2.16.2"><span class="header-section-number">1.2.16.2</span> Post-Copy</h4>
<p>Post-copy migration is an alternative live migration approach. While
pre-copy migration operates by copying data before the VM halt,
post-copy migration opts for another strategy: it immediately suspends
the VM operation on the source and resumes it on the destination – all
with only a minimal subset of the VM’s data.</p>
<p>During this resumed operation, whenever the VM attempts to access a
chunk of data not initially transferred during the move, a page fault
arises. A page fault, in this context, is a type of interrupt generated
when the VM tries to read or write a chunk that is not currently present
on the destination. This triggers the system to retrieve the missing
chunk from the source host, enabling the VM to continue its
operations<span class="citation" data-cites="he2016migration">[28]</span>.</p>
<p>The main advantage of post-copy migration centers around the fact
that it eliminates the necessity of re-transmitting chunks of “dirty” or
changed data before hitting the maximum tolerable downtime. This process
can thus decrease the necessary downtime and also reduces the amount of
network traffic between source and destination.</p>
<p>However, this approach is also not without its drawbacks. Post-copy
migration could potentially lead to extended migration times, as a
consequence of its “fetch-on-demand” model for retrieving chunks. This
model is highly sensitive to network latency and round-trip time (RTT).
Unlike the pre-copy model, this also means that the VM is not available
in full on either the source or the destination during migration,
requiring potential recovery solutions if network connectivity is lost
during the migration.</p>
</section>
<section id="workload-analysis" data-number="0.2.16.3">
<h4 data-number="1.2.16.3"><span class="header-section-number">1.2.16.3</span> Workload Analysis</h4>
<p>Recent studies have explored different strategies to determine the
most suitable timing for virtual machine migration. Even though these
mostly focus on virtual machines, the methodologies proposed could be
adapted for use with various other applications or migration
circumstances, too.</p>
<p>One method<span class="citation" data-cites="baruchi2015workload">[29]</span> proposed identifies
cyclical workload patterns of VMs and leverages this knowledge to delay
migration when it is beneficial. This is achieved by analyzing recurring
patterns that may unnecessarily postpone VM migration, and then
constructing a model of optimal cycles within which VMs can be migrated.
In the context of VM migration, such cycles could for example be
triggered by a large application’s garbage collector that results in
numerous changes to VM memory.</p>
<p>When migration is proposed, the system verifies whether it is in an
optimal cycle for migration. If it is, the migration proceeds; if not,
the migration is postponed until the next cycle. The proposed process
employs a Bayesian classifier to distinguish between favorable and
unfavorable cycles.</p>
<p>Compared to the popular alternative method which usually involves
waiting for a significant amount of unchanged chunks to synchronize
first, the proposed pattern recognition-based approach potentially
offers substantial improvements. The study found that this method
yielded an enhancement of up to 74% in terms of live migration
time/downtime and a 43% reduction concerning the volume of data
transferred over the network.</p>
</section>
</section>
<section id="streams-and-pipelines" data-number="0.2.17">
<h3 data-number="1.2.17"><span class="header-section-number">1.2.17</span> Streams and Pipelines</h3>
<p>Streams and pipelines are fundamental constructs in computer science,
enabling efficient, sequential processing of large datasets without the
need for loading an entire dataset into memory. They form the backbone
of modular and efficient data processing techniques, with each concept
having its unique characteristics and use cases.</p>
<p>A stream represents a continuous sequence of data, serving as a
connector between different points in a system. Streams can be either a
source or a destination for data. Examples include files, network
connections, and standard input/output devices and many others. The
power of streams comes from their ability to process data as it becomes
available; this aspect allows for minimization of memory consumption,
making streams particularly impactful for scenarios involving
long-running processes where data is streamed over extended periods of
time<span class="citation" data-cites="akidau2018streaming">[30]</span>.</p>
<p>Pipelines comprise a series of data processing stages, wherein the
output of one stage directly serves as the input to the next. It’s this
chain of processing stages that forms a “pipeline”. Often, these stages
can run concurrently; this parallel execution can result in a
significant performance improvement due to a higher degree of
concurrency.</p>
<p>One of the classic examples of pipelines is the instruction pipeline
in CPUs, where different stages of instruction execution - fetch,
decode, execute, and writeback - are performed in parallel. This design
increases the instruction throughput of the CPU, allowing it to process
multiple instructions simultaneously at different stages of the
pipeline.</p>
<p>Another familiar implementation is observed in UNIX pipes, a
fundamental part of shells such as GNU Bash or POSIX <code>sh</code>.
Here, the output of a command can be “piped” into another for further
processing; for instance, the results from a <code>curl</code> command
fetching data from an API could be piped into the <code>jq</code> tool
for JSON manipulation<span class="citation" data-cites="peek1994unix">[31]</span>.</p>
</section>
<section id="grpc" data-number="0.2.18">
<h3 data-number="1.2.18"><span class="header-section-number">1.2.18</span> gRPC</h3>
<p>gRPC is an open-source, high-performance remote procedure call (RPC)
framework developed by Google in 2015. It is recognized for its
cross-platform compatibility, supporting a variety of languages
including Go, Rust, JavaScript and more. gRPC is being maintained by the
Cloud Native Computing Foundation (CNCF), which ensures vendor
neutrality.</p>
<p>One of the notable features of the gRPC is its usage of HTTP/2 as the
transport protocol. This allows it to exploit features of HTTP/2 such as
header compression, which minimizes bandwidth usage, and request
multiplexing, enabling multiple requests to be sent concurrently over a
single connection. In addition to HTTP/2, gRPC utilizes Protocol Buffers
(protobuf) as the Interface Definition Language (IDL) and wire format.
Protobuf is a compact, high-performance, and language-neutral mechanism
for data serialization. This makes it preferable over the more dynamic,
but more verbose and slower JSON format often used in REST APIs.</p>
<p>One of the strengths of the gRPC framework is its support for various
types of RPCs. Not only does it support unary RPCs where the client
sends a single request to the server and receives a single response in
return, mirroring the functionality of a traditional function call, but
also server-streaming RPCs, wherein the client sends a request, and the
server responds with a stream of messages. Conversely, in
client-streaming RPCs, the client sends a stream of messages to a server
in response to a request. It also supports bidirectional RPCs, wherein
both client and server can send messages to each other.</p>
<p>What distinguishes gRPC is its pluggable structure that allows for
added functionalities such as load balancing, tracing, health checking,
and authentication, which make it a comprehensive solution for
developing distributed systems<span class="citation" data-cites="google2023grpc">[32]</span>.</p>
</section>
<section id="redis" data-number="0.2.19">
<h3 data-number="1.2.19"><span class="header-section-number">1.2.19</span> Redis</h3>
<p>Redis (Remote Dictionary Server) is an in-memory data structure
store, primarily utilized as an ephemeral database, cache, and message
broker introduced by Salvatore Sanfilippo in 2009. Compared to other
key-value stores and NoSQL databases, Redis supports a multitude of data
structures, including lists, sets, hashes, and bitmaps, making it a good
choice for caching or storing data that does not fit well into a
traditional SQL architecture<span class="citation" data-cites="redis2023introduction">[33]</span>.</p>
<p>One of the primary reasons for Redis’s speed is its reliance on
in-memory data storage rather than on disk, enabling very low-latency
reads and writes. While the primary usecase of Redis is in in-memory
operations, it also supports persistence by flushing data to disk. This
feature broadens the use cases for Redis, allowing it to handle
applications that require longer-term data storage in addition to a
caching mechanism. In addition to it being mostly in-memory, Redis also
supports quick concurrent reads/writes thanks to its non-blocking I/O
model, making it a good choice for systems that require the store to be
available to many workers or clients.</p>
<p>Redis also includes a publish-subscribe (pub-sub) system. This
enables it to function as a message broker, where messages are published
to channels and delivered to all the subscribers interested in those
channels. This makes it a particularly compelling choice for systems
that require both caching and a memory broker, such as queue
systems<span class="citation" data-cites="redis2023pubsub">[34]</span>.</p>
</section>
<section id="s3-and-minio" data-number="0.2.20">
<h3 data-number="1.2.20"><span class="header-section-number">1.2.20</span> S3 and Minio</h3>
<p>S3 is a scalable object storage service, especially designed for
large-scale applications with frequent reads and writes. It is one of
the prominent services offered by Amazon Web Services. S3’s design
allows for global distribution, which means the data can be stored
across multiple geographically diverse servers. This permits fast access
times from virtually any location on the globe, crucial for globally
distributed services or applications with users spread across different
continents.</p>
<p>S3 offers a variety of storage classes for to different needs,
i.e. for whether the requirement is for frequent data access, infrequent
data retrieval, or long-term archival. This ensures that it can meet a
wide array of demands through the same API. S3 also comes equipped with
comprehensive security features, including authentication and
authorization mechanisms.</p>
<p>Communication with S3 is done through a HTTP API. Users and
applications can interact with the stored data - including files and
folders - via this API.<span class="citation" data-cites="aws2023s3">[35]</span>.</p>
<p>Minio is an open-source storage server that is compatible Amazon S3’s
API. Due to it being written in the Go programming language, Minio is
very lightweight and even ships as single static binary. Unlike with AWS
S3, which is only offered as a service, Minio’s open-source nature means
that users have the ability to view, modify, and distribute Minio’s
source code, allowing community-driven development and innovation.</p>
<p>A critical distinction of Minio is its suitability for on-premises
hosting, making it a good fit for organizations with specific security
regulations, those preferring to maintain direct control over their data
and developers prefering to work on the local system. It also supports
horizontal scalability, designed to distribute large quantities of data
across multiple nodes, meaning that it can be used in large-scale
deployments similarly to AWS S3<span class="citation" data-cites="minio2023coreadmin">[36]</span>.</p>
</section>
<section id="cassandra-and-scyllladb" data-number="0.2.21">
<h3 data-number="1.2.21"><span class="header-section-number">1.2.21</span> Cassandra and ScylllaDB</h3>
<p>Apache Cassandra is a wide-column NoSQL database tailored for
large-scale, distributed data management tasks. It blends the
distributed nature of Amazon’s Dynamo model with the structure of
Google’s Bigtable model, leading to a highly available database system.
It is known for its scalability, designed to handle vast amounts of data
spread across numerous servers. Unique to Cassandra is the absence of a
single point of failure, thus ensuring continuous availability and
robustness, which is critical for systems requiring high uptime.</p>
<p>Cassandra’s consistency model is tunable according to needs, ranging
from eventual to strong consistency. It distinguishes itself by not
employing master nodes due to its usage of a peer-to-peer protocol and a
distributed hash ring design. These design choices eradicate the
bottleneck and failure risks associated with master nodes<span class="citation" data-cites="lakshman2010cassandra">[37]</span>.</p>
<p>Despite these robust capabilities, Cassandra does come with certain
limitations. Under heavy load, it experiences high latency that can
negatively affect system performance. Besides this, it also demands
complex configuration and fine-tuning to peform optimally.</p>
<p>In response to the perceived shortcomings of Cassandra, ScyllaDB was
launched in 2015. It shares design principles with Cassandra, such as
compatibility with Cassandra’s API and data model, but has architectural
differences intended to overcome Cassandra’s limitations. It’s primarily
written in C++, contrary to Cassandra’s Java-based code. This
contributes to ScyllaDB’s shared-nothing architecture, a design that
aims to minimize contention and enhance performance.</p>
<p>ScyllaDB was particularly engineered to address one shortcoming of
Cassandra - issues around latency, specifically the 99th percentile
latency that impacts system reliability and predictability. ScyllaDB’s
design improvements and performance gains over Cassandra have been
endorsed by various benchmarking studies<span class="citation" data-cites="grabowski2021scylladb">[38]</span>.</p>
<p>TODO: Add graph of the Cassandra vs. ScyllaDB benchmark from the
benchmarking study</p>
</section>
</section>
<section id="planning" data-number="0.3">
<h2 data-number="1.3"><span class="header-section-number">1.3</span>
Planning</h2>
<section id="pull-based-synchronization-with-userfaultfd" data-number="0.3.1">
<h3 data-number="1.3.1"><span class="header-section-number">1.3.1</span>
Pull-Based Synchronization With <code>userfaultfd</code></h3>
<p><code>userfaultfd</code> allows the implementation of a post-copy
migration scenario. In this setup, a memory region is created on the
destination host. When the migrated application starts to read from this
remote region after it was resumed, it triggers a page fault, which we
want to resolve by fetching the relevant offset from the remote.</p>
<p>Typically, page faults are resolved by the kernel. While this makes
sense for use cases where they can be resolved by loading a local
ressource into memory, here we want to handle the page faults using a
user space program instead. Traditionally, this was possible by
registering a signal handler for the <code>SIGSEGV</code> handler, and
then responding to fault from the program. This however is a fairly
complicated and inefficient process. Instead, we can now use the
<code>userfaultfd</code> system to register a page fault handler
directly without having to go through a signal first.</p>
<p>With <code>userfaultfd</code>, we first register the memory region
that we want to handle page faults in and start a handler in user space
that fetches the missing offsets from the source host in-demand whenever
a page fault occurs. This handler is connected to the registered
region’s <code>userfaultfd</code> API through a file descriptor. To
enable sharing the file descriptor between processes, a UNIX socket can
be used.</p>
</section>
<section id="push-based-synchronization-with-mmap-and-hashing" data-number="0.3.2">
<h3 data-number="1.3.2"><span class="header-section-number">1.3.2</span>
Push-Based Synchronization With <code>mmap</code> and Hashing</h3>
<p>As mentioned before, <code>mmap</code> allows mapping a memory region
to a file. Similarly to how we used a region registered with
<code>userfaultfd</code> before to store the state or application that
is being migrated, we can use this region to do the same. Because the
region is linked to a file, when writes happen to the region, they will
also be written to the corresponding file. If we’re able to detect these
writes and copy the changes to the destination host, we can use this
setup to implement a pre-copy migration system.</p>
<p>While writes done to a <code>mmap</code>ed region are eventually
being written back to the underlying file, this is not the case
immediately, since the kernel still uses caching on an
<code>mmap</code>ed region in order to speed up reads/writes. As a
workaround, we can use the <code>msync</code> syscall, which works
similarly to the <code>sync</code> syscall by flushing any remaining
changes from the cache to the backing file.</p>
<p>In order to actually detect the changes to the underlying file, an
obvious solution might be to use <code>inotify</code>. This however
isn’t possible for <code>mmap</code>ed files, as the file corresponds to
a memory region, and traditional <code>write</code> etc. evens are not
emitted. Instead of using <code>inotify</code> or a similar event-based
system to track changes, we can instead use a polling system. This has
drawbacks - namely latency and computation load - that were attempted to
be worked around in the following implementation, but are inherent to
this approach.</p>
</section>
<section id="push-pull-synchronization-with-fuse" data-number="0.3.3">
<h3 data-number="1.3.3"><span class="header-section-number">1.3.3</span>
Push-Pull Synchronization with FUSE</h3>
<p>Using a file system in user space (FUSE) can serve as the basis for
implementing either a pre- or a post-copy live migration system.
Similarly to the file-based pre-copy approach, we can use
<code>mmap</code> to map the migrated resource’s memory region to a
file. Instead of storing this file on the system’s default filesystem
however, a custom file system is implemented, which allows dropping the
expensive polling system. Since a custom file system allows us to catch
reads (for a post-copy migration scenario, were reads would be responded
to by fetching from the remote), writes (for a pre-copy scenario, where
writes would be forwarded to the destination) and other operations by
the kernel, we no longer need to use <code>inotify</code>.</p>
<p>While implementing such a custom file system in the kernel is
possible, it is a complex task that requires writing a custom kernel
module, using a supported language by the kernel (mostly C or a limited
subset of Rust), and in general having significant knowledge of kernel
internals. Furthermore, since networking would be required to resolve
reads/forward writes from/to the source/destination host, a job that
would usually be done by user space applications, a user space component
would probably also need to be developed in order to support this part
of the synchronization system. Instead of implementing it in the kernel,
we can use the FUSE API. This makes it possible to write the entire file
system in user space, can significantly reduce the complexity of this
approach.</p>
</section>
<section id="mounts-with-nbd" data-number="0.3.4">
<h3 data-number="1.3.4"><span class="header-section-number">1.3.4</span>
Mounts with NBD</h3>
<p>Another <code>mmap</code>-based approach for both pre- and post-copy
migration is to <code>mmap</code> a block device instead of a file. This
block device can be provided through a variety of APIs, for example
NBD.</p>
<p>By providing a NBD device through the kernel’s NBD client, we can
connect the device to a remote NBD server, which in turn hosts the
migratable resource as a memory region. Any reads/writes from/to the
<code>mmap</code>ed memory region are resolved by the NBD device, which
forwards it to the client, which then resolves them using the remote
server; as such, this approach is less so a synchronization (as the
memory region is never actually copied to the destination hist), but
rather a mount of a remote memory region over the NBD protocol.</p>
<p>From an initial overview, the biggest benefit of <code>mmap</code>ing
such a block device instead of a file on a custom file system is the
reduced complexity. For the narrow usecase of memory synchronization,
not all of the features provided by a full file system are be required,
which means that the implementation of a NBD server and client, as well
as the accompanying protocols, is significantly less complex and can
also reduce the overhead of the system as a whole.</p>
</section>
<section id="push-pull-synchronization-with-mounts" data-number="0.3.5">
<h3 data-number="1.3.5"><span class="header-section-number">1.3.5</span>
Push-Pull Synchronization with Mounts</h3>
<section id="overview" data-number="0.3.5.1">
<h4 data-number="1.3.5.1"><span class="header-section-number">1.3.5.1</span> Overview</h4>
<p>This approach also leverages <code>mmap</code> and NBD to handle
reads and writes to the migratable ressource’s memory region, similar to
the prior approaches, but differs from mounts with NBD in a few
significant ways.</p>
<p>Usually, the NBD server and client don’t run on the same system, but
are instead separated over a network. This network commonly is LAN, and
the NBD protocol was designed to access a remote hard drive in this
network. As a result of the protocol being designed for this
low-latency, high-throughput type of network, there are a few
limitations of the NBD protocol when it is being used in a WAN that can
not guarantee the same.</p>
<p>While most wire security issues with the protocol can be worked
around by simply using TLS, the big issue of it’s latency sensitivity
remains. Usually, individual blocks would only be fetched as they are
being accessed, resulting in a ready latency per block that is at least
the RTT. In order to work around this issue, instead of directly
connecting a NBD client to a remote NBD server, a layer of indirection
(called “Mount”) is created. This component consists of both a client
and a server, both of which are running on the local system instead of
being split into a separate remote and local component.</p>
<p>By combining the NBD server and client into this reusabable uit, we
can connect the server to a new backend component with a protocol which
is better suited for WAN usage than NBD. This also allows the
implementation of smart, asynchronous background push/pull strategies
instead of simpliy directly writing to/from the network (called “Managed
Mounts”). The simplest form of the mount API is the direct mount API; it
simply swaps out NBD for a transport-independent RPC framework, but does
not do additional optimizations. It has two simple actors: The client
and the server. Only unidirectional RPCs from the client to the server
are required for this to work, and the required backend service’s
interface is simple:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> BackendRemote <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    ReadAt  <span class="kw">func</span><span class="op">(</span>context context<span class="op">.</span>Context<span class="op">,</span> length <span class="dt">int</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>r ReadAtResponse<span class="op">,</span> err <span class="dt">error</span><span class="op">)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    WriteAt <span class="kw">func</span><span class="op">(</span>context context<span class="op">.</span>Context<span class="op">,</span> p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    Size    <span class="kw">func</span><span class="op">(</span>context context<span class="op">.</span>Context<span class="op">)</span> <span class="op">(</span><span class="dt">int64</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    Sync    <span class="kw">func</span><span class="op">(</span>context context<span class="op">.</span>Context<span class="op">)</span> <span class="dt">error</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The protocol is stateless, as there is only a simple remote reader
and writer interface; there are no distinct protocol phases, either.</p>
<p>TODO: Add protocol sequence diagram TODO: Add state machine
diagram</p>
</section>
<section id="chunking" data-number="0.3.5.2">
<h4 data-number="1.3.5.2"><span class="header-section-number">1.3.5.2</span> Chunking</h4>
<p>And additional issue that was mentioned before that this approach can
approve upon is better chunking support. While it is possible to specify
the NBD protocol’s chunk size by configuring the NBD client and server,
this is limited to only 4KB in the case of Linux’s implementation. If
the RTT between the backend and the NBD server however is large, it
might be preferable to use a much larger chunk size; this used to not be
possible by using NBD directly, but thanks to this layer of indirection
it can be implemented.</p>
<p>Similarly to the Linux kernel’s NBD client, backends themselves might
also have constraints that prevent them from working without a specific
chunk size, or otherwise require aligned reads. This is for example the
case for tape drives, where reads and writes must occur with a fixed
block size and on aligned offsets; furthermore, these linear storage
devices work best if chunks are multiple MBs instead KBs.</p>
<p>It is possible to do this chunking in two places: On the mount API’s
side (meaning the NBD server), or on the (potentially remote) backend’s
side. While this will be discussed further in the results section,
chunking on the backend’s side is usually preferred as doing it
client-side can significantly increase latency due to a read being
required if a non-aligned write occurs, esp. in the case of a WAN
deployment with high RTT.</p>
<p>But even if the backend does not require any kind of chunking to be
accessed - i.e. if it is a remote file - it might still make sense to
limit the maximum supported message size between the NBD server and the
backend, simply to prevent DoS attacks that would require the backend to
allocate large chunks of memory, were such a limit provided by a
chunking system not in place.</p>
</section>
<section id="background-pull-and-push" data-number="0.3.5.3">
<h4 data-number="1.3.5.3"><span class="header-section-number">1.3.5.3</span> Background Pull and
Push</h4>
<p>A pre-copy migration system for the managed API is realized in the
form of pre-emptive pulls that run asynchronously in the background. In
order to optimize for sequential locality, a pull priority heuristic was
introduced; this is used to determine the order in which chunks should
be pulled. Many applications and other migratable resources commonly
access certain parts of their memory first, so if a ressources should be
accessible locally as quickly as possible (so that reads go to the local
cache filled by the pre-emptive pulls, instead of having to wait at
least one RTT to fetch it from the remote), knowing this access pattern
and fetching these sections first can improve latency and throughput
signficantly.</p>
<p>And example of this can be data that consists of one or multiple
headers followed by raw data. If this structure is known, rather than
fetching everything linearly in the background, the headers can be
fetched first in order to allow for i.e. metadata to be displayed before
the rest of the data has been fetched. Similarly so, if a file system is
being synchronized, and the superblocks of a file system are being
stored in a known pattern or known fixed locations, these can be pulled
first, significantly speeding up operations such as directory listings
that don’t require the actual inode’s data to be available.</p>
<p>Post-copy migration conversly is implemented using asynchronous
background push. This push system is started in parallel with the pull
system. It keeps track of which chunks were written to, de-duplicates
remote writes, and periodically writes back these dirty chunks to the
remote backend. This can significantly improve write performance
compared to forwarding writes directly to the remote by being able to
catch multiple writes without having to block for at least the RTT until
the remote write has finished before continuing to the next write.</p>
<p>For the managed mount API, the pre- and post-copy live migration
paradigms are combined to form a hybrid solution. Due to reasons
elaborated on in more detail in the discussion section, the managed
mount API however is primarly intended for efficiently reading from a
remote resource and synching back changes eventually, rather than
migrating a resource between two hosts. For the migration usecase, the
migration API, which will be introduced in the following section,
provides a better solution by building on similar concepts as the
managed mounts API.</p>
</section>
</section>
<section id="pull-based-synchronization-with-migrations" data-number="0.3.6">
<h3 data-number="1.3.6"><span class="header-section-number">1.3.6</span>
Pull-Based Synchronization with Migrations</h3>
<section id="overview-1" data-number="0.3.6.1">
<h4 data-number="1.3.6.1"><span class="header-section-number">1.3.6.1</span> Overview</h4>
<p>Similarly to the managed mount API, this migration API again tracks
changes to the memory of the migratable resource using NBD. As mentioned
before however, the managed mount API is not optimized for the migration
usecase, but rather for efficiently accessing a remote resource. For
live migration, one metric is very important: maximum acceptable
downtime. This refers to the time that a application, VM etc. must be
suspended or otherwise prevented from writing to or reading from the
resource that is being synchronized; the higher this value is, the more
noticable the downtime becomes.</p>
<p>To improve on this the pull-based migration API, the migration
process is split into two distinct phases. This is required due the
constraint mentioned earlier; the mount API does not allow for safe
concurrent access of a remote resource by two readers or writers at the
same time. This poses a signficant problem for the migration scenario,
as the app that is writing to the source device would need to be
suspended before the transfer could even begin, as starting the
destination node would already violate the single-reader, single-writer
constraint of the mount API. This adds significant latency, and is
complicated further by the backend for the managed mount API not
exposing a block itself but rather just serving as a remote that can be
mounted. The migration API on the other hand doesn’t have this
hierarchical system; both the source and destination are peers that
expose block devices on either end.</p>
</section>
<section id="migration-protocol-and-critical-phases" data-number="0.3.6.2">
<h4 data-number="1.3.6.2"><span class="header-section-number">1.3.6.2</span> Migration Protocol and
Critical Phases</h4>
<p>The migration protocol that allows for this defines two new actors:
The seeder and the leecher. A seeder represents a resource that can be
migrated from or a host that exposes a migrabtable resource, while the
leecher represents a client that intents to migrate a resource to
itself. The protocol starts by running an application with the
application’s state on the region <code>mmap</code>ed to the seeder’s
block device, similarly to the managed mount API. Once a leecher
connects to the seeder, the seeder starts tracking any writes to it’s
mount, effectively keeping a list of dirty chunks. Once tracking has
started, the leecher starts pulling chunks from the seeder to it’s local
cache. Once it has received a satisfactory level of locally available
chunks, it asks the seeder to finalize. This then causes the seeder to
suspend the app accessing the memory region on it’s block device,
<code>msync</code>/flushes the it, and returns a list of chunks that
were changed between the point where it started tracking and the flush
has occured. Upon receiving this list, the leecher marks these chunks
are remotes, immediately resumes the application (which is now accessing
the leecher’s block device), and queues the dirty chunks to be pulled in
the background.</p>
<p>TODO: Add protocol sequence diagram TODO: Add state machine
diagram</p>
<p>By splitting the migration into these two distinct phases, the
overhead of having to start the deivce can be skipped and additional app
initialization that doesn’t depend on the app’s state (i.e. memory
allocation, connecting to databases, loading models etc.) can be
performed before the application needs to be suspended. This combines
both the pre-copy algorithm (by pulling the chunks from the seeder ahead
of time) and the post-copy algorithm (by resolving dirtyc chunsk from
the seeder after the VM has been migrated) into one coherent protocol.
As will be discussed further in the results section, the maximum
tolerable downtime can be drastically reduced, and dirty chunks don’t
need to be re-transmitted multiple times. Effectively, it allows
dropping this downtime to the time it takes to <code>msync</code> the
seeder’s app state, the RTT and, if they are being accessed immediately,
how long it takes to fetch the chunks that were written in between the
start of it tracking and finalizing. The migration API can use the same
preemptive pull system as the managed mount API and benefit from it’s
optimizations, but does not use the background push system.</p>
<p>An interesting question to ask with this two-step migration API is
when to start the finalization step. The finalization phase in the
protocol is critical, and it is hard or impossible to recover from
depending on the specific implementation. While the synchronization
itself could be safely recovered from by simply calling
<code>Finalize</code> multiple times to restart it. But since
<code>Finalize</code> needs to return a list of dirty chunks, it
requires the app on the seeder to be suspended before
<code>Finalize</code> can return, an operation that might not be
idempotent.</p>
</section>
</section>
</section>
<section id="implementation" data-number="0.4">
<h2 data-number="1.4"><span class="header-section-number">1.4</span>
Implementation</h2>
<section id="userfaults-in-go-with-userfaultfd" data-number="0.4.1">
<h3 data-number="1.4.1"><span class="header-section-number">1.4.1</span>
Userfaults in Go with <code>userfaultfd</code></h3>
<section id="registration-and-handlers" data-number="0.4.1.1">
<h4 data-number="1.4.1.1"><span class="header-section-number">1.4.1.1</span> Registration and
Handlers</h4>
<p>By listening to page faults, we can know when a process wants to
access a specific offset of memory that is not yet available. As
mentioned before, we can use this event to then fetch this chunk of
memory from the remote, mapping it to the offset on which the page fault
occured, thus effectively only fetching data when it is required.
Instead of registering signal handlers, we can use the
<code>userfaultfd</code> system introduced with Linux 4.3<span class="citation" data-cites="corbet2015linux43">[39]</span> to handle
these faults in userspace in a more idiomatic way.</p>
<p>In the Go implementation created for this thesis,
<code>userfaultfd-go</code>, <code>userfaultfd</code> works by first
creating a region of memory, e.g. by using <code>mmap</code>, which is
then registered with the <code>userfaultfd</code> API:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Creating the `userfaultfd` API</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>uffd<span class="op">,</span> _<span class="op">,</span> errno <span class="op">:=</span> syscall<span class="op">.</span>Syscall<span class="op">(</span>constants<span class="op">.</span>NR_userfaultfd<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>uffdioAPI <span class="op">:=</span> constants<span class="op">.</span>NewUffdioAPI<span class="op">(</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    constants<span class="op">.</span>UFFD_API<span class="op">,</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span><span class="op">,</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Allocating the region</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>l <span class="op">:=</span> <span class="dt">int</span><span class="op">(</span>math<span class="op">.</span>Ceil<span class="op">(</span><span class="dt">float64</span><span class="op">(</span>length<span class="op">)/</span><span class="dt">float64</span><span class="op">(</span>pagesize<span class="op">))</span> <span class="op">*</span> <span class="dt">float64</span><span class="op">(</span>pagesize<span class="op">))</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>b<span class="op">,</span> err <span class="op">:=</span> syscall<span class="op">.</span>Mmap<span class="op">(</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">-</span><span class="dv">1</span><span class="op">,</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span><span class="op">,</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    l<span class="op">,</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    syscall<span class="op">.</span>PROT_READ<span class="op">|</span>syscall<span class="op">.</span>PROT_WRITE<span class="op">,</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    syscall<span class="op">.</span>MAP_PRIVATE<span class="op">|</span>syscall<span class="op">.</span>MAP_ANONYMOUS<span class="op">,</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="co">// Registering the region</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>uffdioRegister <span class="op">:=</span> constants<span class="op">.</span>NewUffdioRegister<span class="op">(</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    constants<span class="op">.</span>CULong<span class="op">(</span>start<span class="op">),</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    constants<span class="op">.</span>CULong<span class="op">(</span>l<span class="op">),</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    constants<span class="op">.</span>UFFDIO_REGISTER_MODE_MISSING<span class="op">,</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>syscall<span class="op">.</span>Syscall<span class="op">(</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>  syscall<span class="op">.</span>SYS_IOCTL<span class="op">,</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>  uffd<span class="op">,</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>  constants<span class="op">.</span>UFFDIO_REGISTER<span class="op">,</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>  <span class="dt">uintptr</span><span class="op">(</span>unsafe<span class="op">.</span>Pointer<span class="op">(&amp;</span>uffdioRegister<span class="op">))</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
<p>This is abstracted into a single
<code>Register(length int) ([]byte, UFFD, uintptr, error)</code>
function. Once this region has been registered, the
<code>userfaultfd</code> API’s file descriptor and the offset is passed
over a UNIX socket:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>syscall<span class="op">.</span>Sendmsg<span class="op">(</span><span class="dt">int</span><span class="op">(</span>f<span class="op">.</span>Fd<span class="op">()),</span> <span class="ot">nil</span><span class="op">,</span> syscall<span class="op">.</span>UnixRights<span class="op">(</span>b<span class="op">...),</span> <span class="ot">nil</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<p>Where it can then be received by the handler:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>buf <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> syscall<span class="op">.</span>CmsgSpace<span class="op">(</span>num<span class="op">*</span><span class="dv">4</span><span class="op">))</span> <span class="co">// See https://github.com/ftrvxmtrx/fd/blob/master/fd.go#L51</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>syscall<span class="op">.</span>Recvmsg<span class="op">(</span><span class="dt">int</span><span class="op">(</span>f<span class="op">.</span>Fd<span class="op">()),</span> <span class="ot">nil</span><span class="op">,</span> buf<span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">// ..</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>msgs<span class="op">,</span> err <span class="op">:=</span> syscall<span class="op">.</span>ParseSocketControlMessage<span class="op">(</span>buf<span class="op">)</span></span></code></pre></div>
<p>The handler itself receives the address that has triggered the page
fault by polling the transferred file descriptor, which is then
responded to by fetching the relevant chunk from a provided reader and
sending it to the faulting memory region over the same socket:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Receiving the fage fault address</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>unix<span class="op">.</span>Poll<span class="op">(</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">[]</span>unix<span class="op">.</span>PollFd<span class="op">{{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        Fd<span class="op">:</span>     <span class="dt">int32</span><span class="op">(</span>uffd<span class="op">),</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        Events<span class="op">:</span> unix<span class="op">.</span>POLLIN<span class="op">,</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}},</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">-</span><span class="dv">1</span><span class="op">,</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>pagefault <span class="op">:=</span> <span class="op">(*(*</span>constants<span class="op">.</span>UffdPagefault<span class="op">)(</span>unsafe<span class="op">.</span>Pointer<span class="op">(&amp;</span>arg<span class="op">[</span><span class="dv">0</span><span class="op">])))</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>addr <span class="op">:=</span> constants<span class="op">.</span>GetPagefaultAddress<span class="op">(&amp;</span>pagefault<span class="op">)</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Fetching the missing chunk from the provided backend</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>p <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> pagesize<span class="op">)</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>n<span class="op">,</span> err <span class="op">:=</span> src<span class="op">.</span>ReadAt<span class="op">(</span>p<span class="op">,</span> <span class="dt">int64</span><span class="op">(</span><span class="dt">uintptr</span><span class="op">(</span>addr<span class="op">)-</span>start<span class="op">))</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Sending the missing chunk to the faulting memory region&#39;s `userfaultfd` API:</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>cpy <span class="op">:=</span> constants<span class="op">.</span>NewUffdioCopy<span class="op">(</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    p<span class="op">,</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    addr<span class="op">&amp;^</span>constants<span class="op">.</span>CULong<span class="op">(</span>pagesize<span class="dv">-1</span><span class="op">),</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    constants<span class="op">.</span>CULong<span class="op">(</span>pagesize<span class="op">),</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span><span class="op">,</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span><span class="op">,</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>syscall<span class="op">.</span>Syscall<span class="op">(</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    syscall<span class="op">.</span>SYS_IOCTL<span class="op">,</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uintptr</span><span class="op">(</span>uffd<span class="op">),</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    constants<span class="op">.</span>UFFDIO_COPY<span class="op">,</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uintptr</span><span class="op">(</span>unsafe<span class="op">.</span>Pointer<span class="op">(&amp;</span>cpy<span class="op">)),</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
<p>Similarly to the registration API, this is also wrapped into a
reusable
<code>func Handle(uffd UFFD, start uintptr, src io.ReaderAt) error</code>
function.</p>
</section>
<section id="userfaultfd-backends" data-number="0.4.1.2">
<h4 data-number="1.4.1.2"><span class="header-section-number">1.4.1.2</span> <code>userfaultfd</code>
Backends</h4>
<p>Thanks to <code>userfaultfd</code> being mostly useful for post-copy
migration, the backend can be simplifed to a simple pull-only reader
interface (<code>ReadAt(p []byte, off int64) (n int, err error)</code>).
This means that almost any <code>io.ReaderAt</code> can be used to
provide chunks to a <code>userfaultfd</code>-registered memory region,
and access to this reader is guaranteed to be aligned to system’s page
size, which is typically 4KB. By having this simple backend interface,
and thus only requiring read-only access, it is possible to implement
the migration backend in many different ways. A simple backend can for
example return a pattern to the memory region:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>a abcReader<span class="op">)</span> ReadAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">copy</span><span class="op">(</span>p<span class="op">,</span> bytes<span class="op">.</span>Repeat<span class="op">([]</span><span class="dt">byte</span><span class="op">{</span><span class="ch">&#39;A&#39;</span> <span class="op">+</span> <span class="dt">byte</span><span class="op">(</span>off<span class="op">%</span><span class="dv">20</span><span class="op">)},</span> <span class="bu">len</span><span class="op">(</span>p<span class="op">)))</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n<span class="op">,</span> <span class="ot">nil</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In Go specifically, many objects can be exposed as an
<code>io.ReaderAt</code>, including a file. This makes it possible to
simply pass in any file as a backend, essentially mimicking a call to
<code>mmap</code> with <code>MAP_SHARED</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>f<span class="op">,</span> err <span class="op">:=</span> os<span class="op">.</span>OpenFile<span class="op">(*</span>file<span class="op">,</span> os<span class="op">.</span>O_RDONLY<span class="op">,</span> os<span class="op">.</span>ModePerm<span class="op">)</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>b<span class="op">,</span> uffd<span class="op">,</span> start<span class="op">,</span> err <span class="op">:=</span> mapper<span class="op">.</span>Register<span class="op">(</span><span class="dt">int</span><span class="op">(</span>s<span class="op">.</span>Size<span class="op">()))</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>mapper<span class="op">.</span>Handle<span class="op">(</span>uffd<span class="op">,</span> start<span class="op">,</span> f<span class="op">)</span></span></code></pre></div>
<p>Similarly so, a remote file, i.e. one that is being stored in S3, can
be used as a <code>userfaultfd</code> backend as well; here, HTTP range
requests allow for fetching only the chunks that are being required by
the application accessing the registered memory region, effectively
making it possible to map a remote S3 object into memory:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>mc<span class="op">,</span> err <span class="op">:=</span> minio<span class="op">.</span>New<span class="op">(*</span>s3Endpoint<span class="op">,</span> <span class="co">/* ... */</span><span class="op">)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>f<span class="op">,</span> err <span class="op">:=</span> mc<span class="op">.</span>GetObject<span class="op">(</span>ctx<span class="op">,</span> <span class="op">*</span>s3BucketName<span class="op">,</span> <span class="op">*</span>s3ObjectName<span class="op">,</span> minio<span class="op">.</span>GetObjectOptions<span class="op">{})</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>b<span class="op">,</span> uffd<span class="op">,</span> start<span class="op">,</span> err <span class="op">:=</span> mapper<span class="op">.</span>Register<span class="op">(</span><span class="dt">int</span><span class="op">(</span>s<span class="op">.</span>Size<span class="op">()))</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>mapper<span class="op">.</span>Handle<span class="op">(</span>uffd<span class="op">,</span> start<span class="op">,</span> f<span class="op">)</span></span></code></pre></div>
</section>
</section>
<section id="file-based-synchronization" data-number="0.4.2">
<h3 data-number="1.4.2"><span class="header-section-number">1.4.2</span>
File-Based Synchronization</h3>
<section id="caching-restrictions" data-number="0.4.2.1">
<h4 data-number="1.4.2.1"><span class="header-section-number">1.4.2.1</span> Caching Restrictions</h4>
<p>As mentioned earlier, this approach uses <code>mmap</code> to map a
memory region to a file. By default however, <code>mmap</code> doesn’t
write back changes to memory; instead, it simply makes the backing file
available as a memory region, keeping changes to the region in memory,
no matter whether the file was opened as read-only or read-writable. To
work around this, Linux provides the <code>MAP_SHARED</code> flag; this
tells the kernel to eventually write back changes to the memory region
to the corresponding regions of the backing file.</p>
<p>Linux caches reads to the backing file similarly to how it does if
<code>read</code> etc. are being used, meaning that only the first page
fault would be responded to by reading from disk; this means that any
future changes to the backing file would not be represented in the
<code>mmap</code>ed region, similarly to how <code>userfaultfd</code>
handles it. The same applies to writes, meaning that in the same way
that files need to be <code>sync</code>ed in order for them to be
flushed to disk, <code>mmap</code>ed regions need to be
<code>msync</code>ed in order to flush changes to the backing file. This
is particularly important for a memory usecase, since reading from the
backing file without flushing first would result in the synchronization
of potentially stale data, and is different to how traditional file
synchronization can handle this usecase, where the Linux file cache
would respond with the changes if the file is read from disk even if
<code>sync</code> was not called beforehand. For file I/O, it is
possible to skip the kernel cache and read/write directly from/to the
disk by passing the <code>O_DIRECT</code> flag to <code>open</code>, but
this flag is ignored by <code>mmap</code>.</p>
</section>
<section id="detecting-file-changes" data-number="0.4.2.2">
<h4 data-number="1.4.2.2"><span class="header-section-number">1.4.2.2</span> Detecting File Changes</h4>
<p>In order to actually watch for changes, at first glance, the obvious
choice would be to use <code>inotify</code>, which would allow the
registration of <code>write</code> or <code>sync</code> even handlers to
catch writes to the memory region by registering them on the backing
file. As mentioned earlier however, Linux doesn’t emit these events on
<code>mmap</code>ed files, so an alternative must be used; the best
option here is to instead poll for either attribute changes (i.e. the
“Last Modified” attribute of the backing file), or by continously
hashing the file to check if it has changed. Hashing continously with
this pollig method can have significant downsides, especially in a
migration scenario, where it raises the guaranteed minimum latency by
having to wait for at least the next polling cycle. Hashing the entire
file is also a an I/O- and CPU-intensive process, because in order to
compute the hash, the entire file needs to be read at some point. Within
the context of the file-based synchronization approach however, it is
the only option available.</p>
<p>To speed up the process of hashing, instead of hashing the entire
file, we can instead hash individual chunks of the file, in effect
implementing a delta synchronization algorithm. This can be implemented
by opening the file multiple times, hashing individual offsets using
each of the opened files, and aggregating the chunks that have been
changed. When picking algorithms for this chunk-based hashing algorithm,
two metrics are of relevance: the algorithm’s throughput with which it
can calculate hashes, and the prevalence of hash collisions, where two
different inputs produce the same hashes, leading to a chunk change not
being detected. Furthermore, if the underlying algorithm is CPU- and not
I/O-bound, using multiple open files can increase throughput
substantially by allowing for better concurrent processing. Not only
does this decrease the time spent on each individual hashing iteration
of the polling process, but dividing the file into smaller chunks that
all have their own hashes to compare with the remote’s hashes can also
decrease the amount of network traffic that is required to sync the
changes, since a small change in the backing file leads to the transfer
of a smaller chunk.</p>
</section>
<section id="synchronization-protocol" data-number="0.4.2.3">
<h4 data-number="1.4.2.3"><span class="header-section-number">1.4.2.3</span> Synchronization
Protocol</h4>
<p>The delta synchronization protocol for this approach is similar to
the one used by <code>rsync</code>, but simplifie. It supports
synchronizing multiple files at the same time by using the file names as
IDs, and also supports a central forwarding hub instead of requiring
peer-to-peer connectivity between all hosts, which also reduces network
traffic since this central hub could also be used to forward one stream
to all other peers instead of having to send it multiple times. The
protocol defines three actors: The multiplexer, file advertiser and file
receiver.</p>
<p>TODO: Add sequence diagram for the protocol</p>
</section>
<section id="multiplexer-hub" data-number="0.4.2.4">
<h4 data-number="1.4.2.4"><span class="header-section-number">1.4.2.4</span> Multiplexer Hub</h4>
<p>The multiplexer hub accepts mTLS connections from peers. When a peer
connects, the client certificate is parsed to read the common name,
which is then being used as the synchronization ID. The multiplexer
spawns a goroutine to allow for more peers to connection. In the
goroutine, it reads the type of the peer. If the type is
<code>src-control</code>, it starts by reading a file name from the
connection, and registers the connection as the one providing a file
with this name, after which it broadcasts the file as now being
available. For the <code>dst-control</code> peer type, it listens to the
broadcasted files from the <code>src-control</code> peers, and relays
and newly advertised and previously registered file names to the
<code>dst-control</code> peers so that it can start receiving them:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="st">&quot;src-control&quot;</span><span class="op">:</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Decoding the file name</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    file <span class="op">:=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    utils<span class="op">.</span>DecodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> <span class="op">&amp;</span>file<span class="op">)</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    syncerSrcControlConns<span class="op">[</span>file<span class="op">]</span> <span class="op">=</span> conn</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    syncerSrcControlConnsBroadcaster<span class="op">.</span>Broadcast<span class="op">(</span>file<span class="op">)</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="st">&quot;dst-control&quot;</span><span class="op">:</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> wg sync<span class="op">.</span>WaitGroup</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    wg<span class="op">.</span>Add<span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">go</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Subscription to send all future file names</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        l <span class="op">:=</span> syncerSrcControlConnsBroadcaster<span class="op">.</span>Listener<span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> file <span class="op">:=</span> <span class="kw">range</span> l<span class="op">.</span>Ch<span class="op">()</span> <span class="op">{</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>            utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> file<span class="op">)</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>      <span class="co">// ...</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}()</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Sending the previously known file names</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> file <span class="op">:=</span> <span class="kw">range</span> syncerSrcControlConns <span class="op">{</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>        utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> file<span class="op">)</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>    wg<span class="op">.</span>Wait<span class="op">()</span></span></code></pre></div>
<p>For the <code>dst</code> type, the multiplexer hub decodes a file
name from the connection, looks for a corresponding
<code>src-control</code> peer, and if it has found a matching one, it
creates and sends a new ID for this connection to the
<code>src-control</code> peer. After this, it waits until a
<code>src-control</code> peer has connected to the hub with this ID as
well as a new <code>src-data</code> peer by listening for broadcasts of
<code>src-data</code> peer IDs. After this has occured, it spawns two
new goroutines that copy data to and from this newly created
synchronization connection and the connection of the <code>dst</code>
peer, effectively relaying all packets between the two. For the
<code>src-data</code> peer type, it decodes the ID for the peer, and
broadcasts the ID, which allows the <code>dst</code> peer to continue
operating:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="st">&quot;dst&quot;</span><span class="op">:</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Decoding the file name</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  file <span class="op">:=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  utils<span class="op">.</span>DecodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> <span class="op">&amp;</span>file<span class="op">)</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Finding the `src-control` peer</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  controlConn<span class="op">,</span> ok <span class="op">:=</span> syncerSrcControlConns<span class="op">[</span>file<span class="op">]</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Sending the ID and waiting for a data connection</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  id <span class="op">:=</span> uuid<span class="op">.</span>NewString<span class="op">()</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>controlConn<span class="op">,</span> id<span class="op">)</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  l <span class="op">:=</span> dataConnsBroadcaster<span class="op">.</span>Listener<span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> dataConn net<span class="op">.</span>Conn</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> candidate <span class="op">:=</span> <span class="kw">range</span> l<span class="op">.</span>Ch<span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> candidate<span class="op">.</span>id <span class="op">==</span> id <span class="op">{</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>        dataConn <span class="op">=</span> candidate<span class="op">.</span>conn</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>        l<span class="op">.</span>Close<span class="op">()</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Copying data between both connections</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">go</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>Copy<span class="op">(</span>dataConn<span class="op">,</span> conn<span class="op">)</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}()</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">go</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>Copy<span class="op">(</span>conn<span class="op">,</span> dataConn<span class="op">)</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>  <span class="op">}()</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="st">&quot;src-data&quot;</span><span class="op">:</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Receiving the ID</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>  id <span class="op">:=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>  utils<span class="op">.</span>DecodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> <span class="op">&amp;</span>id<span class="op">)</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Broadcasting the ID</span></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>  dataConnsBroadcaster<span class="op">.</span>Broadcast<span class="op">(</span>connWithID<span class="op">{</span>id<span class="op">,</span> conn<span class="op">})</span></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span></code></pre></div>
</section>
<section id="file-advertisement" data-number="0.4.2.5">
<h4 data-number="1.4.2.5"><span class="header-section-number">1.4.2.5</span> File Advertisement</h4>
<p>The file advertisement system connects to the multiplexer hub and
registers itself a <code>src-control</code> peer, after which it sends
the advertised file name. It starts a loop that handles <code>dst</code>
peer types, which, as mentioned earlier, send an ID. Once such an ID is
received, it spawns a new goroutine, which connects to the hub again and
registers itself as a <code>src-data</code> peer, and sends the ID it
has received earlier to allow connecting it to the matching
<code>dst</code> peer:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>f<span class="op">,</span> err <span class="op">:=</span> os<span class="op">.</span>OpenFile<span class="op">(</span>src<span class="op">,</span> os<span class="op">.</span>O_RDONLY<span class="op">,</span> os<span class="op">.</span>ModePerm<span class="op">)</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>dataConn<span class="op">,</span> <span class="st">&quot;src-data&quot;</span><span class="op">)</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>dataConn<span class="op">,</span> id<span class="op">)</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>After this initial handshake is complete, the main synchronization
loop is started, which initiates the file transmission to the
<code>dst</code> peer through the multiplexer hub. In order to allow for
termination, it checks if the <code>syncStopped</code> flag has been set
by a context cancellation which case it returns:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>syncStopped <span class="op">:=</span> <span class="ot">false</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="cf">go</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;-</span>ctx<span class="op">.</span>Done<span class="op">()</span> <span class="co">// Context is supplied by the caller</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    syncStopped <span class="op">=</span> <span class="ot">true</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span></code></pre></div>
<p>If this is not the case, it waits for the specified polling interval,
after which it restarts the transmission:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>done <span class="op">:=</span> <span class="ot">false</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> done <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> syncStopped <span class="op">{</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Finish the synchronization</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        SendFile<span class="op">(</span>parallel<span class="op">,</span> f<span class="op">,</span> src<span class="op">,</span> blocksize<span class="op">,</span> dataConn<span class="op">,</span> verbose<span class="op">)</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  ...</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        done <span class="op">=</span> <span class="ot">true</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Start the synchronization</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    SendFile<span class="op">(</span>parallel<span class="op">,</span> f<span class="op">,</span> src<span class="op">,</span> blocksize<span class="op">,</span> dataConn<span class="op">,</span> verbose<span class="op">)</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Wait until the next polling cycle starts</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    time<span class="op">.</span>Sleep<span class="op">(</span>pollDuration<span class="op">)</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="file-receiver" data-number="0.4.2.6">
<h4 data-number="1.4.2.6"><span class="header-section-number">1.4.2.6</span> File Receiver</h4>
<p>The file receiver also connects to the multiplexer hub, this time
registering itself as a <code>dst-control</code> peer. After it has
received a file name from the multiplexer hub, it connects to the
multiplexer hub again - this time registering itself as a
<code>dst</code> peer, which creates leading directories, opens up the
destination file and registers itself:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Connection and registration</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>syncerConn<span class="op">,</span> err <span class="op">:=</span> d<span class="op">.</span>DialContext<span class="op">(</span>ctx<span class="op">,</span> <span class="st">&quot;tcp&quot;</span><span class="op">,</span> syncerRaddr<span class="op">)</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>syncerConn<span class="op">,</span> <span class="st">&quot;dst-control&quot;</span><span class="op">)</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">{</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  file <span class="op">:=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  utils<span class="op">.</span>DecodeJSONFixedLength<span class="op">(</span>syncerConn<span class="op">,</span> <span class="op">&amp;</span>file<span class="op">)</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">go</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Connection and registration</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    dataConn<span class="op">,</span> err <span class="op">:=</span> d<span class="op">.</span>DialContext<span class="op">(</span>ctx<span class="op">,</span> <span class="st">&quot;tcp&quot;</span><span class="op">,</span> syncerRaddr<span class="op">)</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ..</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>dataConn<span class="op">,</span> <span class="st">&quot;dst&quot;</span><span class="op">)</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Destination directory and file setup</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    dst <span class="op">:=</span> getDstPath<span class="op">(</span>file<span class="op">)</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    os<span class="op">.</span>MkdirAll<span class="op">(</span>filepath<span class="op">.</span>Dir<span class="op">(</span>dst<span class="op">),</span> os<span class="op">.</span>ModePerm<span class="op">)</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    f<span class="op">,</span> err <span class="op">:=</span> os<span class="op">.</span>OpenFile<span class="op">(</span>dst<span class="op">,</span> os<span class="op">.</span>O_WRONLY<span class="op">|</span>os<span class="op">.</span>O_CREATE<span class="op">,</span> os<span class="op">.</span>ModePerm<span class="op">)</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}()</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The file name is now sent to the multiplexer again, causing it to
look for a peer that advertises the requested file. If such a peer is
found, it starts the file receiver process in a loop, exiting only once
the file has been completely synced:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Sending the file name</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>dataConn<span class="op">,</span> file<span class="op">)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">{</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Receiving one set of delta changes</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  ReceiveFile<span class="op">(</span>parallel<span class="op">,</span> f<span class="op">,</span> dst<span class="op">,</span> blocksize<span class="op">,</span> dataConn<span class="op">,</span> verbose<span class="op">)</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Termination</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> once<span class="op">(</span>file<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="file-transmission" data-number="0.4.2.7">
<h4 data-number="1.4.2.7"><span class="header-section-number">1.4.2.7</span> File Transmission</h4>
<p>This component does the actual transmission in each iteration of the
delta synchronization algorithm. It receives the remote hashes from the
multiplexer hub, calculates the matching local hashes and compares them,
which it sends the hashes that don’t match back to the file receiver via
the multiplexer hub:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Receiving remote hashes</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>remoteHashes <span class="op">:=</span> <span class="op">[]</span><span class="dt">string</span><span class="op">{}</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>utils<span class="op">.</span>DecodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> <span class="op">&amp;</span>remoteHashes<span class="op">)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Calculating the hashes</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>localHashes<span class="op">,</span> cutoff<span class="op">,</span> err <span class="op">:=</span> GetHashesForBlocks<span class="op">(</span>parallel<span class="op">,</span> path<span class="op">,</span> blocksize<span class="op">)</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Comparing the hashes</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>blocksToSend <span class="op">:=</span> <span class="op">[]</span><span class="dt">int64</span><span class="op">{}</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i<span class="op">,</span> localHash <span class="op">:=</span> <span class="kw">range</span> localHashes <span class="op">{</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    j <span class="op">:=</span> <span class="dt">int64</span><span class="op">(</span>i<span class="op">)</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span><span class="op">(</span>remoteHashes<span class="op">)</span> <span class="op">&lt;=</span> i <span class="op">{</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>        blocksToSend <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>blocksToSend<span class="op">,</span> j<span class="op">)</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> localHash <span class="op">!=</span> remoteHashes<span class="op">[</span>i<span class="op">]</span> <span class="op">{</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        blocksToSend <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>blocksToSend<span class="op">,</span> j<span class="op">)</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a><span class="co">// Sending the non-matching hashes</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> blocksToSend<span class="op">)</span></span></code></pre></div>
<p>If the remote has sent less hashes than were calculated locally, it
asks the remote to truncate it’s file to the size of the local file that
is being synchronized, after which it sends the updated data for the
file in the order that the changed hashes were sent:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Local file is empty, truncate remote file to zero</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span><span class="op">(</span>remoteHashes<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> <span class="bu">len</span><span class="op">(</span>localHashes<span class="op">)</span> <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="co">// ...</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Grow/shrink remote file</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> cutoff<span class="op">)</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Read changed chunks from file and copy them to the remote connection</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i<span class="op">,</span> blockToSend <span class="op">:=</span> <span class="kw">range</span> blocksToSend <span class="op">{</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    backset <span class="op">:=</span> <span class="dt">int64</span><span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">==</span> <span class="bu">len</span><span class="op">(</span>blocksToSend<span class="op">)-</span><span class="dv">1</span> <span class="op">{</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        backset <span class="op">=</span> cutoff</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>    b <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> blocksize<span class="op">-</span>backset<span class="op">)</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>    file<span class="op">.</span>ReadAt<span class="op">(</span>b<span class="op">,</span> blockToSend<span class="op">*(</span>blocksize<span class="op">))</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>    m<span class="op">,</span> err <span class="op">:=</span> conn<span class="op">.</span>Write<span class="op">(</span>b<span class="op">)</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="hash-calculation" data-number="0.4.2.8">
<h4 data-number="1.4.2.8"><span class="header-section-number">1.4.2.8</span> Hash Calculation</h4>
<p>The hash calculation implements the concurrent hashing of both the
file transmitter and receiver. It uses a semaphore to limit the amount
of concurrent access to the file that is being hashed, and a wait group
to detect that the calculation has finished:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">// The lock and semaphore</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> wg sync<span class="op">.</span>WaitGroup</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>wg<span class="op">.</span>Add<span class="op">(</span><span class="dt">int</span><span class="op">(</span>blocks<span class="op">))</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>lock <span class="op">:=</span> semaphore<span class="op">.</span>NewWeighted<span class="op">(</span>parallel<span class="op">)</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Concurrent hash calculation</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="op">:=</span> <span class="dt">int64</span><span class="op">(</span><span class="dv">0</span><span class="op">);</span> i <span class="op">&lt;</span> blocks<span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    j <span class="op">:=</span> i</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">go</span> calculateHash<span class="op">(</span>j<span class="op">)</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>wg<span class="op">.</span>Wait<span class="op">()</span></span></code></pre></div>
<p>Worker goroutines acquire a lock of this semaphore and calculate a
CRC32 hash, which is a weak but fast hashing algorithm. For easier
transmission, the hashes are hex-encoded and collected:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>calculateHash <span class="op">:=</span> <span class="kw">func</span><span class="op">(</span>j <span class="dt">int64</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> lock<span class="op">.</span>Acquire<span class="op">(</span>context<span class="op">.</span>Background<span class="op">(),</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    checkFile<span class="op">,</span> err <span class="op">:=</span> os<span class="op">.</span>Open<span class="op">(</span>file<span class="op">)</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Hash calculation of the specific chunk</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    hash <span class="op">:=</span> crc32<span class="op">.</span>NewIEEE<span class="op">()</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>CopyN<span class="op">(</span>hash<span class="op">,</span> io<span class="op">.</span>NewSectionReader<span class="op">(</span>checkFile<span class="op">,</span> j<span class="op">*(</span>blocksize<span class="op">),</span> blocksize<span class="op">),</span> blocksize<span class="op">)</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Hash encoding</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    hashes<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> hex<span class="op">.</span>EncodeToString<span class="op">(</span>hash<span class="op">.</span>Sum<span class="op">(</span><span class="ot">nil</span><span class="op">))</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="file-reception" data-number="0.4.2.9">
<h4 data-number="1.4.2.9"><span class="header-section-number">1.4.2.9</span> File Reception</h4>
<p>This is the receiving component of one delta synchronization
iteration. It starts by calculating hashes for the existing local copy
of the file, which it then sends to the remote before it waits to
receive the remote’s hashes and potential truncation request:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Local hash calculation</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>localHashes<span class="op">,</span> _<span class="op">,</span> err <span class="op">:=</span> GetHashesForBlocks<span class="op">(</span>parallel<span class="op">,</span> path<span class="op">,</span> blocksize<span class="op">)</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Sending the hashes to the remote</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>utils<span class="op">.</span>EncodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> localHashes<span class="op">)</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Receiving the remote hashes and the truncation request</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>blocksToFetch <span class="op">:=</span> <span class="op">[]</span><span class="dt">int64</span><span class="op">{}</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>utils<span class="op">.</span>DecodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> <span class="op">&amp;</span>blocksToFetch<span class="op">)</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>cutoff <span class="op">:=</span> <span class="dt">int64</span><span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>utils<span class="op">.</span>DecodeJSONFixedLength<span class="op">(</span>conn<span class="op">,</span> <span class="op">&amp;</span>cutoff<span class="op">)</span></span></code></pre></div>
<p>If the remote detected that the file needs to be cleared (by sending
a negative cutoff value), the receiver truncates the file; similarly so,
if it has detected that the file has grown or shrunk since the last
synchronization cycle, it shortens or extends it, after which the chunks
are read from the connection and written to the local file:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Clearing the file</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> cutoff <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    file<span class="op">.</span>Truncate<span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="ot">nil</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="co">/// ...</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Shrinking or growing the file</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>s<span class="op">,</span> err <span class="op">:=</span> os<span class="op">.</span>Stat<span class="op">(</span>path<span class="op">)</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>newSize <span class="op">:=</span> <span class="op">(((</span>blocksToFetch<span class="op">[</span><span class="bu">len</span><span class="op">(</span>blocksToFetch<span class="op">)-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> blocksize<span class="op">)</span> <span class="op">-</span> cutoff<span class="op">)</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>diff <span class="op">:=</span> s<span class="op">.</span>Size<span class="op">()</span> <span class="op">-</span> newSize</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> diff <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If the file on the server got smaller, truncate the local file accordingly</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    file<span class="op">.</span>Truncate<span class="op">(</span>newSize<span class="op">)</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If the file on the server grew, grow the local file accordingly</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    file<span class="op">.</span>Seek<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>CopyN<span class="op">(</span>file<span class="op">,</span> nopReader<span class="op">{},</span> <span class="op">-</span>diff<span class="op">)</span></span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i<span class="op">,</span> blockToFetch <span class="op">:=</span> <span class="kw">range</span> blocksToFetch <span class="op">{</span></span>
<span id="cb25-26"><a href="#cb25-26" aria-hidden="true" tabindex="-1"></a>    backset <span class="op">:=</span> <span class="dt">int64</span><span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb25-27"><a href="#cb25-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">==</span> <span class="bu">len</span><span class="op">(</span>blocksToFetch<span class="op">)-</span><span class="dv">1</span> <span class="op">{</span></span>
<span id="cb25-28"><a href="#cb25-28" aria-hidden="true" tabindex="-1"></a>        backset <span class="op">=</span> cutoff</span>
<span id="cb25-29"><a href="#cb25-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb25-30"><a href="#cb25-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-31"><a href="#cb25-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Receiving the chunk</span></span>
<span id="cb25-32"><a href="#cb25-32" aria-hidden="true" tabindex="-1"></a>    b <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> blocksize<span class="op">-</span>backset<span class="op">)</span></span>
<span id="cb25-33"><a href="#cb25-33" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>ReadFull<span class="op">(</span>conn<span class="op">,</span> b<span class="op">)</span></span>
<span id="cb25-34"><a href="#cb25-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-35"><a href="#cb25-35" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Writing the chunk to the local file</span></span>
<span id="cb25-36"><a href="#cb25-36" aria-hidden="true" tabindex="-1"></a>    file<span class="op">.</span>WriteAt<span class="op">(</span>b<span class="op">,</span> blockToFetch<span class="op">*(</span>blocksize<span class="op">))</span></span>
<span id="cb25-37"><a href="#cb25-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
</section>
<section id="fuse-implementation-in-go" data-number="0.4.3">
<h3 data-number="1.4.3"><span class="header-section-number">1.4.3</span>
FUSE Implementation in Go</h3>
<p>Implementing a FUSE in Go can be split into two separate tasks:
Creating a backend for a file abstraction API and creating an adapter
between this API and a FUSE library.</p>
<p>Developing a backend for a file system abstraction API such as
<code>afero.Fs</code> instead of implementing it to work with FUSE
bindings directly offers several advantages. This layer of indirection
allows splitting the FUSE implementation from the actual
<code>inode</code> structure of the system, which makes it unit
testable<span class="citation" data-cites="pojtinger2022stfstests">[40]</span>. This is a high priority
due to the complexities and edge cases involved with creating a file
system. A standard API also offers the ability to implement things such
as caching by simply nesting multiple <code>afero.Fs</code> interfaces,
and the required interface is rather minimal<span class="citation" data-cites="francia2023afero">[41]</span>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Fs <span class="kw">interface</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    Create<span class="op">(</span>name <span class="dt">string</span><span class="op">)</span> <span class="op">(</span>File<span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    Mkdir<span class="op">(</span>name <span class="dt">string</span><span class="op">,</span> perm os<span class="op">.</span>FileMode<span class="op">)</span> <span class="dt">error</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    MkdirAll<span class="op">(</span>path <span class="dt">string</span><span class="op">,</span> perm os<span class="op">.</span>FileMode<span class="op">)</span> <span class="dt">error</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    Open<span class="op">(</span>name <span class="dt">string</span><span class="op">)</span> <span class="op">(</span>File<span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    OpenFile<span class="op">(</span>name <span class="dt">string</span><span class="op">,</span> flag <span class="dt">int</span><span class="op">,</span> perm os<span class="op">.</span>FileMode<span class="op">)</span> <span class="op">(</span>File<span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    Remove<span class="op">(</span>name <span class="dt">string</span><span class="op">)</span> <span class="dt">error</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    RemoveAll<span class="op">(</span>path <span class="dt">string</span><span class="op">)</span> <span class="dt">error</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    Rename<span class="op">(</span>oldname<span class="op">,</span> newname <span class="dt">string</span><span class="op">)</span> <span class="dt">error</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    Stat<span class="op">(</span>name <span class="dt">string</span><span class="op">)</span> <span class="op">(</span>os<span class="op">.</span>FileInfo<span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    Name<span class="op">()</span> <span class="dt">string</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    Chmod<span class="op">(</span>name <span class="dt">string</span><span class="op">,</span> mode os<span class="op">.</span>FileMode<span class="op">)</span> <span class="dt">error</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    Chown<span class="op">(</span>name <span class="dt">string</span><span class="op">,</span> uid<span class="op">,</span> gid <span class="dt">int</span><span class="op">)</span> <span class="dt">error</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    Chtimes<span class="op">(</span>name <span class="dt">string</span><span class="op">,</span> atime time<span class="op">.</span>Time<span class="op">,</span> mtime time<span class="op">.</span>Time<span class="op">)</span> <span class="dt">error</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The STFS project<span class="citation" data-cites="pojtinger2022stfs">[42]</span> has shown that by using this
abstraction layer, seemingly incompatible, non-linear backends can still
be maGpped to a file system. The project is backend by a tape drive,
which is inherently append-only and optimized for linear access. Thanks
to the inclusion of an on-disk index and various optimization methods,
the resulting file system was still performant enough for standard use,
while also supporting most of the features required by the average user
such as symlinks, file updates and more.</p>
<p>By using a project like sile-fystem<span class="citation" data-cites="waibel2022silefystem">[43]</span>, it is also possible to
use any <code>afero.Fs</code> filesystem as a FUSE backend; this can
signficantly reduce the required implementation overhead, as it doesn’t
require writing a custom adapter:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Creating the file system</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>serve <span class="op">:=</span> filesystem<span class="op">.</span>NewFileSystem<span class="op">(</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ..</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  afero<span class="op">.</span>NewOsFs<span class="op">(),</span>  <span class="co">// afero.Fs implementation here</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Mounting the file system</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>fuse<span class="op">.</span>Mount<span class="op">(</span>viper<span class="op">.</span>GetString<span class="op">(</span>mountpoint<span class="op">),</span> serve<span class="op">,</span> cfg<span class="op">)</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>While the FUSE approach to synchronization is interesting, even with
these available libraries the required overhead of implementing it (as
shown by prior projects like STFS) as well as other factors that will be
mentioned later led to this approach not being pursued further.</p>
</section>
<section id="nbd-with-go-nbd" data-number="0.4.4">
<h3 data-number="1.4.4"><span class="header-section-number">1.4.4</span>
NBD with <code>go-nbd</code></h3>
<section id="overview-2" data-number="0.4.4.1">
<h4 data-number="1.4.4.1"><span class="header-section-number">1.4.4.1</span> Overview</h4>
<p>Due to a lack of existing, lean and maintained NBD libraries for Go,
a custom pure Go NBD library was implemented. Most NBD libraries also
only provide a server and no the client component, but both are needed
for the NBD-based migration approach to work. By not having to rely on
CGo or a pre-existing NBD library like <code>nbdkit</code>, this custom
library can also skip a significant amount of the overhead that is
typically associated with C interoperability, particularly in the
context of concurrency in Go with CGo <span class="citation" data-cites="grieger2015cgo">[44]</span>.</p>
</section>
<section id="server" data-number="0.4.4.2">
<h4 data-number="1.4.4.2"><span class="header-section-number">1.4.4.2</span> Server</h4>
<p>The NBD server is implemented completely in userspace, and there are
no kernel components involved. The backend interface that is expected by
the server is very simple and only requires four methods to be
implemented; <code>ReadAt</code>, <code>WriteAt</code>,
<code>Size</code> and <code>Sync</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Backend <span class="kw">interface</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    ReadAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    WriteAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    Size<span class="op">()</span> <span class="op">(</span><span class="dt">int64</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    Sync<span class="op">()</span> <span class="dt">error</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The key difference between this backend design and the one used for
<code>userfaultfd-go</code> is that they also support writes and other
operations that would typically be expected for a complete block device,
such as flushing data with <code>Sync()</code>. An example
implementation of this backend is the file backend; since a file is
conceptually similar to a block device, the overhead of creating the
backend is minimal:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>FileBackend<span class="op">)</span> ReadAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    n<span class="op">,</span> err <span class="op">=</span> b<span class="op">.</span>file<span class="op">.</span>ReadAt<span class="op">(</span>p<span class="op">,</span> off<span class="op">)</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>FileBackend<span class="op">)</span> WriteAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    n<span class="op">,</span> err <span class="op">=</span> b<span class="op">.</span>file<span class="op">.</span>WriteAt<span class="op">(</span>p<span class="op">,</span> off<span class="op">)</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>FileBackend<span class="op">)</span> Size<span class="op">()</span> <span class="op">(</span><span class="dt">int64</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    stat<span class="op">,</span> err <span class="op">:=</span> b<span class="op">.</span>file<span class="op">.</span>Stat<span class="op">()</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ..</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> stat<span class="op">.</span>Size<span class="op">(),</span> <span class="ot">nil</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>FileBackend<span class="op">)</span> Sync<span class="op">()</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b<span class="op">.</span>file<span class="op">.</span>Sync<span class="op">()</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In order to serve such a backend, <code>go-nbd</code> exposes
<code>Handle</code> function:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> Handle<span class="op">(</span>conn net<span class="op">.</span>Conn<span class="op">,</span> exports <span class="op">[]</span>Export<span class="op">,</span> options <span class="op">*</span>Options<span class="op">)</span> <span class="dt">error</span></span></code></pre></div>
<p>By not depending on a specific transport layer and instead only
depending on a generic <code>net.Conn</code>, it is possible to easily
integrate <code>go-nbd</code> in existing client/server systems or to
switch out the typical TCP transport layer with i.e. QUIC. By not
requiring <code>dial/accept</code> semantics it is also possible to use
a P2P communication layer for peer-to-peer NBD such as WebRTC with
weron<span class="citation" data-cites="pojtinger2023weron">[45]</span>,
which also provides the necessary <code>net.Conn</code> interface.</p>
<p>In addition to this <code>net.Conn</code>, options can be provided to
the server; these include the ability to make the server read-only by
blocking write operations, or to set the preferred block size. The
actual backend is linked to the server through the concept of an
export:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> Export <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    Name        <span class="dt">string</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    Description <span class="dt">string</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    Backend backend<span class="op">.</span>Backend</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This allows a single server to expose multiple backends that are
identified with a name and description, which can, in the memory
synchronization scenario, be used to identify multiple shared memory
regions.</p>
<p>To make the implementation of the NBD protocol easier, negotation and
transmission phase headers and and other structured data is modelled
using Go structs:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> NegotiationOptionHeader <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    OptionMagic <span class="dt">uint64</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    ID          <span class="dt">uint32</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    Length      <span class="dt">uint32</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> NegotiationReplyHeader <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    ReplyMagic <span class="dt">uint64</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    ID         <span class="dt">uint32</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    Type       <span class="dt">uint32</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    Length     <span class="dt">uint32</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>In order to keep the actual handshake as simple as possible, only the
fixed newstyle handshake is implemented, which also makes the
implementation compliant with the baseline specification as defined by
the protocol<span class="citation" data-cites="blake2023nbd">[25]</span>. The negotiation starts by the
server sending the negotiation header to the NBD client and ignoring the
client’s flags:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Sending the negotiation header</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>binary<span class="op">.</span>Write<span class="op">(</span>conn<span class="op">,</span> binary<span class="op">.</span>BigEndian<span class="op">,</span> protocol<span class="op">.</span>NegotiationNewstyleHeader<span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    OldstyleMagic<span class="op">:</span>  protocol<span class="op">.</span>NEGOTIATION_MAGIC_OLDSTYLE<span class="op">,</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    OptionMagic<span class="op">:</span>    protocol<span class="op">.</span>NEGOTIATION_MAGIC_OPTION<span class="op">,</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    HandshakeFlags<span class="op">:</span> protocol<span class="op">.</span>NEGOTIATION_HANDSHAKE_FLAG_FIXED_NEWSTYLE<span class="op">,</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Discard client flags (uint32)</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>_<span class="op">,</span> err <span class="op">:=</span> io<span class="op">.</span>CopyN<span class="op">(</span>io<span class="op">.</span>Discard<span class="op">,</span> conn<span class="op">,</span> <span class="dv">4</span><span class="op">)</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>The option negotiation phase is implemented using a simple loop,
which either breaks on success or returns in the case of an error. For
the Go implementation, it is possible to use the <code>binary</code>
package to correctly encode and decode the NBD packets and then
switching on the encoded option ID:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Read the header</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> optionHeader protocol<span class="op">.</span>NegotiationOptionHeader</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    binary<span class="op">.</span>Read<span class="op">(</span>conn<span class="op">,</span> binary<span class="op">.</span>BigEndian<span class="op">,</span> <span class="op">&amp;</span>optionHeader<span class="op">)</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  Validate the packet</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> optionHeader<span class="op">.</span>OptionMagic <span class="op">!=</span> protocol<span class="op">.</span>NEGOTIATION_MAGIC_OPTION <span class="op">{</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ErrInvalidMagic</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Handle the option by it&#39;s ID</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> optionHeader<span class="op">.</span>ID <span class="op">{</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this handshake, the <code>NEGOTIATION_ID_OPTION_INFO</code> and
<code>NEGOTIATION_ID_OPTION_GO</code> options exchange information about
the chosen export (i.e. block size, export size, name and description),
and if <code>GO</code> is specified, immediately continue on to the
transmission phase. If an export is not found, the server aborts the
connection. In order to allow for enumeration of available exports, the
<code>NEGOTIATION_ID_OPTION_LIST</code> allows for returning the list of
exports to the client, and <code>NEGOTIATION_ID_OPTION_ABORT</code>
allows aborting handshake, which can be necessary if i.e. the
<code>NEGOTIATION_ID_OPTION_INFO</code> was chosen but the client can’t
handle the exposed export, i.e. due to it not supporting the advertised
block size.</p>
<p>The actual transmission phase is implemented in a similar way, by
reading headers in a loop, switchin on the message type and handling it
accordingly. <code>TRANSMISSION_TYPE_REQUEST_READ</code> forwards a read
request to the selected export’s backend and sends the relevant chunk to
the client, <code>TRANSMISSION_TYPE_REQUEST_WRITE</code> reads the
offset and chunk from the client, and writes it to the export’s
backend:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Reading the chunk to be written from the client&#39;s connection</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>n<span class="op">,</span> err <span class="op">:=</span> io<span class="op">.</span>ReadAtLeast<span class="op">(</span>conn<span class="op">,</span> b<span class="op">[:</span>requestHeader<span class="op">.</span>Length<span class="op">],</span> <span class="dt">int</span><span class="op">(</span>requestHeader<span class="op">.</span>Length<span class="op">))</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Writing it to the backend</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>export<span class="op">.</span>Backend<span class="op">.</span>WriteAt<span class="op">(</span>b<span class="op">[:</span>n<span class="op">],</span> <span class="dt">int64</span><span class="op">(</span>requestHeader<span class="op">.</span>Offset<span class="op">))</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Acknowledging the write to the client</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>binary<span class="op">.</span>Write<span class="op">(</span>conn<span class="op">,</span> binary<span class="op">.</span>BigEndian<span class="op">,</span> protocol<span class="op">.</span>TransmissionReplyHeader<span class="op">{</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    ReplyMagic<span class="op">:</span> protocol<span class="op">.</span>TRANSMISSION_MAGIC_REPLY<span class="op">,</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    Error<span class="op">:</span>      <span class="dv">0</span><span class="op">,</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    Handle<span class="op">:</span>     requestHeader<span class="op">.</span>Handle<span class="op">,</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span></code></pre></div>
<p>It is here that the read-only option is implemented by sending a
permission error in case of writes:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> options<span class="op">.</span>ReadOnly <span class="op">{</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Discard the write command&#39;s data</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    _<span class="op">,</span> err <span class="op">:=</span> io<span class="op">.</span>CopyN<span class="op">(</span>io<span class="op">.</span>Discard<span class="op">,</span> conn<span class="op">,</span> <span class="dt">int64</span><span class="op">(</span>requestHeader<span class="op">.</span>Length<span class="op">))</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sending the error reply</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>    binary<span class="op">.</span>Write<span class="op">(</span>conn<span class="op">,</span> binary<span class="op">.</span>BigEndian<span class="op">,</span> protocol<span class="op">.</span>TransmissionReplyHeader<span class="op">{</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>        ReplyMagic<span class="op">:</span> protocol<span class="op">.</span>TRANSMISSION_MAGIC_REPLY<span class="op">,</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>        Error<span class="op">:</span>      protocol<span class="op">.</span>TRANSMISSION_ERROR_EPERM<span class="op">,</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>        Handle<span class="op">:</span>     requestHeader<span class="op">.</span>Handle<span class="op">,</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Finally, the <code>TRANSMISSION_TYPE_REQUEST_DISC</code> transmission
message type gracefully disconnects the client from the server and
causes the backend to sync, i.e. to flush and outstanding writes to
disk. This is especially important in order to support the lifecycle of
the migration API.</p>
</section>
<section id="client" data-number="0.4.4.3">
<h4 data-number="1.4.4.3"><span class="header-section-number">1.4.4.3</span> Client</h4>
<p>Unlike the server, the client is implemented by using both the
kernel’s NBD client and a userspace component. In order to use the
kernel NBD client, it is necessary to first find a free NBD device
(<code>/dev/nbd*</code>); these devices are allocated by the kernel NBD
module and can be specified with the <code>nbds_max</code>
parameter<span class="citation" data-cites="linux2023nbd">[46]</span>.
In order to find a free device, we can either specify it manually, or
check <code>sysfs</code> for a NBD device that reports a zero size:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Using a glob on sysfs for the NBD device size</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>statPaths<span class="op">,</span> err <span class="op">:=</span> filepath<span class="op">.</span>Glob<span class="op">(</span>path<span class="op">.</span>Join<span class="op">(</span><span class="st">&quot;/sys&quot;</span><span class="op">,</span> <span class="st">&quot;block&quot;</span><span class="op">,</span> <span class="st">&quot;nbd*&quot;</span><span class="op">,</span> <span class="st">&quot;size&quot;</span><span class="op">))</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Finding the first device that reports a zero zsize</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _<span class="op">,</span> statPath <span class="op">:=</span> <span class="kw">range</span> statPaths <span class="op">{</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>    rsize<span class="op">,</span> err <span class="op">:=</span> os<span class="op">.</span>ReadFile<span class="op">(</span>statPath<span class="op">)</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    size<span class="op">,</span> err <span class="op">:=</span> strconv<span class="op">.</span>ParseInt<span class="op">(</span>strings<span class="op">.</span>TrimSpace<span class="op">(</span><span class="dt">string</span><span class="op">(</span>rsize<span class="op">)),</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">64</span><span class="op">)</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> size <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> filepath<span class="op">.</span>Join<span class="op">(</span><span class="st">&quot;/dev&quot;</span><span class="op">,</span> filepath<span class="op">.</span>Base<span class="op">(</span>filepath<span class="op">.</span>Dir<span class="op">(</span>statPath<span class="op">))),</span> <span class="ot">nil</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>After a free NBD device has been found, the client can be started by
calling <code>Connect</code> with a <code>net.Conn</code> and options,
similarly to the server:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> Connect<span class="op">(</span>conn net<span class="op">.</span>Conn<span class="op">,</span> device <span class="op">*</span>os<span class="op">.</span>File<span class="op">,</span> options <span class="op">*</span>Options<span class="op">)</span> <span class="dt">error</span></span></code></pre></div>
<p>This time, the options can define additonal information such as the
client’s preferred blocksize, connection timeouts or requested export
name, which, in this scenario, can be used to refer to a specific memory
region. The kernel’s NBD device is then configured to use the
connection; the relevant <code>ioctl</code> constants are extracted by
using CGo, or hard-coded values if CGo is not available:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Only use CGo if it is available</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co">//go:build linux &amp;&amp; cgo</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Importing the kernel headers</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="co">#include &lt;sys/ioctl.h&gt;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="co">#include &lt;linux/nbd.h&gt;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="st">&quot;C&quot;</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> <span class="op">(</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Extracting the `ioctl` numbers with `CGo`</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    NEGOTIATION_IOCTL_SET_SOCK        <span class="op">=</span> C<span class="op">.</span>NBD_SET_SOCK</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
<p>The handshake for the NBD cleint is negotiated in userspace by Go.
Similarly to the server, the client only supports the “fixed newstyle”
negotiatiation and aborts otherwise. The negotiation is once again
implemented as a simple loop similarly to the server with it switching
on the type; on <code>NEGOTIATION_TYPE_REPLY_INFO</code>, the client
receives the export size, and with
<code>NEGOTIATION_TYPE_INFO_BLOCKSIZE</code> it receives the used block
size, which it then valides to be within the specified bounds and as a
valid power of two, falling back to the preffered block size supplied by
the options if possible:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Falling back to the client&#39;s prefered block size if none is provided, and checking if the server&#39;s advertised size is within the clients&#39;s bounds as supplied by the options</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> options<span class="op">.</span>BlockSize <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    chosenBlockSize <span class="op">=</span> info<span class="op">.</span>PreferredBlockSize</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> options<span class="op">.</span>BlockSize <span class="op">&gt;=</span> info<span class="op">.</span>MinimumBlockSize <span class="op">&amp;&amp;</span> options<span class="op">.</span>BlockSize <span class="op">&lt;=</span> info<span class="op">.</span>MaximumBlockSize <span class="op">{</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    chosenBlockSize <span class="op">=</span> options<span class="op">.</span>BlockSize</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ErrUnsupportedServerBlockSize</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Validating upper and lower supported bounds set by the kernel&#39;s NBD client</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> chosenBlockSize <span class="op">&gt;</span> MaximumBlockSize <span class="op">{</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ErrMaximumBlockSize</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> chosenBlockSize <span class="op">&lt;</span> MinimumBlockSize <span class="op">{</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ErrMinimumBlockSize</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Validating that the chosen block size is a power of two</span></span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">!((</span>chosenBlockSize <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">((</span>chosenBlockSize <span class="op">&amp;</span> <span class="op">(</span>chosenBlockSize <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">==</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ErrBlockSizeNotPowerOfTwo</span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>After this relevant metadata has been fetched from the server, the
kernel NBD client is further configured with these values using
<code>ioctl</code>, after which the <code>DO_IT</code>
<code>ioctl</code> number is used to asynchronously start the kernel’s
NBD client:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>syscall<span class="op">.</span>Syscall<span class="op">(</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    syscall<span class="op">.</span>SYS_IOCTL<span class="op">,</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    device<span class="op">.</span>Fd<span class="op">(),</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    ioctl<span class="op">.</span>NEGOTIATION_IOCTL_SET_BLOCKSIZE<span class="op">,</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uintptr</span><span class="op">(</span>chosenBlockSize<span class="op">),</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a><span class="cf">go</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>    syscall<span class="op">.</span>Syscall<span class="op">(</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>        syscall<span class="op">.</span>SYS_IOCTL<span class="op">,</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>        device<span class="op">.</span>Fd<span class="op">(),</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>        ioctl<span class="op">.</span>NEGOTIATION_IOCTL_DO_IT<span class="op">,</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span></code></pre></div>
<p>In addition to being able to configure the client itself, the client
library can also be used to list the exports of a server; for this,
another handshake is initiated, but this time the
<code>NEGOTIATION_ID_OPTION_LIST</code> option is provided, after which
the client reads the export information from the server and
disconnects:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>exportNames <span class="op">:=</span> <span class="op">[]</span><span class="dt">string</span><span class="op">{}</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">{</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reading the export name&#39;s length</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> exportNameLength <span class="dt">uint32</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">:=</span> binary<span class="op">.</span>Read<span class="op">(</span>info<span class="op">,</span> binary<span class="op">.</span>BigEndian<span class="op">,</span> <span class="op">&amp;</span>exportNameLength<span class="op">);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// All the exports have been received</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> errors<span class="op">.</span>Is<span class="op">(</span>err<span class="op">,</span> io<span class="op">.</span>EOF<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reading the export name</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>    exportName <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> exportNameLength<span class="op">)</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>ReadFull<span class="op">(</span>info<span class="op">,</span> exportName<span class="op">)</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>    exportNames <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>exportNames<span class="op">,</span> <span class="dt">string</span><span class="op">(</span>exportName<span class="op">))</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="client-lifecycle" data-number="0.4.4.4">
<h4 data-number="1.4.4.4"><span class="header-section-number">1.4.4.4</span> Client Lifecycle</h4>
<p>The final <code>DO_IT</code> <code>ioctl</code> never returns until
it is disconnected, meaning that an external system must be used to
detect whether the device is actually ready. There are two fundamental
ways of doing this: By polling <code>sysfs</code> for the size parameter
as it was done for finding an unused NBD device, or by using
<code>udev</code>.</p>
<p><code>udev</code> manages devices in Linux, and as a device becomes
available, the kernel sends an event using this subsystem. By
subscribing to this system with the expected NBD device name to catch
when it becomes available, it is possible to have a reliable and
idiomatic way of detecting the ready state:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Connecting to `udev`</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>udevConn<span class="op">.</span>Connect<span class="op">(</span>netlink<span class="op">.</span>UdevEvent<span class="op">)</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Subscribing to events for the device name</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>udevConn<span class="op">.</span>Monitor<span class="op">(</span>udevReadyCh<span class="op">,</span> udevErrCh<span class="op">,</span> <span class="op">&amp;</span>netlink<span class="op">.</span>RuleDefinitions<span class="op">{</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    Rules<span class="op">:</span> <span class="op">[]</span>netlink<span class="op">.</span>RuleDefinition<span class="op">{</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>            Env<span class="op">:</span> <span class="kw">map</span><span class="op">[</span><span class="dt">string</span><span class="op">]</span><span class="dt">string</span><span class="op">{</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;DEVNAME&quot;</span><span class="op">:</span> device<span class="op">.</span>Name<span class="op">(),</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">},</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a><span class="co">// Waiting for the device to become available</span></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a><span class="cf">go</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;-</span>udevReadyCh</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>    options<span class="op">.</span>OnConnected<span class="op">()</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span></code></pre></div>
<p>In reality however, due to overheads in <code>udev</code>, it can be
faster to use polling instead of the even system, which is why it is
possible to set the <code>ReadyCheckUdev</code> option in the NBD client
to <code>false</code>, which uses polling instead:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Opening up the NBD device&#39;s size file in `sysfs`</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>sizeFile<span class="op">,</span> err <span class="op">:=</span> os<span class="op">.</span>Open<span class="op">(</span>filepath<span class="op">.</span>Join<span class="op">(</span><span class="st">&quot;/sys&quot;</span><span class="op">,</span> <span class="st">&quot;block&quot;</span><span class="op">,</span> filepath<span class="op">.</span>Base<span class="op">(</span>device<span class="op">.</span>Name<span class="op">()),</span> <span class="st">&quot;size&quot;</span><span class="op">))</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">{</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reading the size file and parsing it&#39;s contents as a number</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    sizeFile<span class="op">.</span>Seek<span class="op">(</span><span class="dv">0</span><span class="op">,</span> io<span class="op">.</span>SeekStart<span class="op">)</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    io<span class="op">.</span>ReadAll<span class="op">(</span>sizeFile<span class="op">)</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    size<span class="op">,</span> err <span class="op">:=</span> strconv<span class="op">.</span>ParseInt<span class="op">(</span>strings<span class="op">.</span>TrimSpace<span class="op">(</span><span class="dt">string</span><span class="op">(</span>rsize<span class="op">)),</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">64</span><span class="op">)</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If the size is no longer reported as zero, return</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> size <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>        options<span class="op">.</span>OnConnected<span class="op">()</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If the device is not yet ready, sleep until the next polling cycle</span></span>
<span id="cb44-18"><a href="#cb44-18" aria-hidden="true" tabindex="-1"></a>    time<span class="op">.</span>Sleep<span class="op">(</span>options<span class="op">.</span>ReadyCheckPollInterval<span class="op">)</span></span>
<span id="cb44-19"><a href="#cb44-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Similarly to the setup lifecycle, the teardown lifecycle is also as
an asynchronous operation. It works by calling three <code>ioctl</code>s
on the NBD device’s file descriptor, causing it to disconnect from the
server and causing the prior <code>DO_IT</code> syscall to return, which
in turn causes the prior call to <code>Connect</code> to return:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Complete any remaining reads/writes</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>syscall<span class="op">.</span>Syscall<span class="op">(</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    syscall<span class="op">.</span>SYS_IOCTL<span class="op">,</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    device<span class="op">.</span>Fd<span class="op">(),</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    ioctl<span class="op">.</span>TRANSMISSION_IOCTL_CLEAR_QUE<span class="op">,</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span><span class="op">,</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Disconnect from the NBD server</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>syscall<span class="op">.</span>Syscall<span class="op">(</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    syscall<span class="op">.</span>SYS_IOCTL<span class="op">,</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>    device<span class="op">.</span>Fd<span class="op">(),</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>    ioctl<span class="op">.</span>TRANSMISSION_IOCTL_DISCONNECT<span class="op">,</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span><span class="op">,</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a><span class="co">// Disassociate the socket from the NBD device so that it can be used again</span></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a>syscall<span class="op">.</span>Syscall<span class="op">(</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true" tabindex="-1"></a>    syscall<span class="op">.</span>SYS_IOCTL<span class="op">,</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true" tabindex="-1"></a>    device<span class="op">.</span>Fd<span class="op">(),</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true" tabindex="-1"></a>    ioctl<span class="op">.</span>TRANSMISSION_IOCTL_CLEAR_SOCK<span class="op">,</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span><span class="op">,</span></span>
<span id="cb45-23"><a href="#cb45-23" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
</section>
<section id="optimizing-access-to-the-block-device" data-number="0.4.4.5">
<h4 data-number="1.4.4.5"><span class="header-section-number">1.4.4.5</span> Optimizing Access to the
Block Device</h4>
<p>When <code>open</code>ing the block devie that the client is
connected to, the kernel usually provides a caching/buffer mechanism,
requiring an expensive <code>sync</code> syscall to flush outstanding
changes to the NBD client. As mentioend earlier, by using
<code>O_DIRECT</code> it is possible to skip this caching layer and
write all changes directly to the NBD client and thus the server, which
is particularly useful in a case where both the client and server are on
the same host, and the amount of time for <code>sync</code>ing should be
minimal, as is the case for a migration scenario. Using
<code>O_DIRECT</code> however does come with the downside of requiring
reads/writes that are aligned to the system’s page size, which is
possible to implement in the specific application using the device to
access a resource, but not in a generic way.</p>
</section>
<section id="combining-the-nbd-client-and-server-to-a-mount" data-number="0.4.4.6">
<h4 data-number="1.4.4.6"><span class="header-section-number">1.4.4.6</span> Combining the NBD Client
and Server to a Mount</h4>
<p>When both the client and server are started on the same host, it is
possible to connect them in an efficient way by creating a connected
UNIX socket pair, returning a file descriptor for both the server and
the client respectively, after which both components can be started in a
new goroutine:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Creating the socket pair</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>fds<span class="op">,</span> err <span class="op">:=</span> syscall<span class="op">.</span>Socketpair<span class="op">(</span>syscall<span class="op">.</span>AF_UNIX<span class="op">,</span> syscall<span class="op">.</span>SOCK_STREAM<span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co">// ..</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Starting the server on file descriptor 1</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="cf">go</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    sf <span class="op">:=</span> os<span class="op">.</span>NewFile<span class="op">(</span><span class="dt">uintptr</span><span class="op">(</span>fds<span class="op">[</span><span class="dv">0</span><span class="op">]),</span> <span class="st">&quot;server&quot;</span><span class="op">)</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>    c<span class="op">,</span> err <span class="op">:=</span> net<span class="op">.</span>FileConn<span class="op">(</span>sf<span class="op">)</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    sc <span class="op">:=</span> c<span class="op">.(*</span>net<span class="op">.</span>UnixConn<span class="op">)</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>    server<span class="op">.</span>Handle<span class="op">(</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>        d<span class="op">.</span>sc<span class="op">,</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a><span class="co">// Starting the client on file descriptor 1</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a><span class="cf">go</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>    cf <span class="op">:=</span> os<span class="op">.</span>NewFile<span class="op">(</span><span class="dt">uintptr</span><span class="op">(</span>fds<span class="op">[</span><span class="dv">1</span><span class="op">]),</span> <span class="st">&quot;client&quot;</span><span class="op">)</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>    c<span class="op">,</span> err <span class="op">:=</span> net<span class="op">.</span>FileConn<span class="op">(</span>cf<span class="op">)</span></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>    cc <span class="op">:=</span> c<span class="op">.(*</span>net<span class="op">.</span>UnixConn<span class="op">)</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a>    client<span class="op">.</span>Connect<span class="op">(</span>d<span class="op">.</span>cc<span class="op">,</span> <span class="co">/* ... */</span><span class="op">)</span></span>
<span id="cb46-29"><a href="#cb46-29" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span></code></pre></div>
<p>This once again shows the benefit of not requiring a specific
transport layer or <code>accept</code> semantics for the NBD library, as
this makes it possible to skip the usually required TCP handshake for
NBD.</p>
<p>This form of a combined client and server on the local device, with
the server’s backend providing the actual ressource, forms a direct path
mount - where the path to the block device can be passed to the
application consuming or providing the ressource, which can then choose
to <code>open</code>, <code>mmap</code> etc. it. In addition to this
simple path-based mount, a file mount is provided. This simply opens up
the path as a file, so that it can be accessed with the common
<code>read</code>/<code>write</code> syscalls; the benefit over simply
using the path mount and handling the access in the application
consuming the ressource is that common pitfalls around the lifecycle
(<code>Close</code> and <code>Sync</code>) can be handled within the
mount API directly.</p>
<p>The direct slice mount works similarly to the file mount, with the
difference being that it <code>mmap</code>s the NBD device, bringing a
variety of benefits such as not requiring syscalls to read/write from
the memory region as mentioned before. The benefit of using the slice
API over simply using the direct path mount API letting the application
<code>mmap</code> the block device itself is once again the lifecycle,
where <code>Close</code> and <code>Sync</code> handle the complexities
of managing <code>mmap</code>ed regions, esp. around garbage collection
and flushing, in the mount directly. As for the API design, another
aspect however is critical; thanks to it providing a standard Go slice
instead of a file, it is possible to use this interface to provide
streaming ability to applications that expect to work with a
<code>[]byte</code>, without requiring changes to the application
itself:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>d <span class="op">*</span>DirectSliceMount<span class="op">)</span> Open<span class="op">()</span> <span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span></code></pre></div>
<p>It is also possible to format the backend for a NBD server/mount with
a filesystem and mount the underlying filesystem on the host that
accesses a resource, where a file on this filesystem can then be
<code>open</code>ed/<code>mmap</code>ed similarly to the FUSE approach.
This is particularly useful if there are multiple memory regions which
all belong to the same application to synchronize, as it removes the
need to start multiple block devices and reduces the latency overhead
associated with it. This solution can be implemented by i.e. calling
<code>mkfs.ext4</code> on a block device directly or by formatting the
NBD backend ahead of time, which does however come at the cost of
storing and transferring the file system metadata as well as the
potential latency overhead of mounting it.</p>
</section>
</section>
<section id="managed-mounts-with-r3map" data-number="0.4.5">
<h3 data-number="1.4.5"><span class="header-section-number">1.4.5</span>
Managed Mounts with r3map</h3>
<section id="stages" data-number="0.4.5.1">
<h4 data-number="1.4.5.1"><span class="header-section-number">1.4.5.1</span> Stages</h4>
<p>In order to implement a chunking system and related components, a
pipeline of readers/writers is a useful abstraction layer; as a result,
the mount API is based on a pipeline of multiple
<code>ReadWriterAt</code> stages:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ReadWriterAt <span class="kw">interface</span> <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    ReadAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    WriteAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This way, it is possible to forward calls to the NBD backends like
<code>Size</code> and <code>Sync</code> directly to the underlying
backend, but can chain the <code>ReadAt</code> and <code>WriteAt</code>
methods, which carry actual data, into a pipeline of other
<code>ReadWriterAt</code>s.</p>
</section>
<section id="chunking-1" data-number="0.4.5.2">
<h4 data-number="1.4.5.2"><span class="header-section-number">1.4.5.2</span> Chunking</h4>
<p>One such <code>ReadWriterAt</code> is the the
<code>ArbitraryReadWriterAt</code>. This chunking component allows
breaking down a larger data stream into smaller chunks at aligned
offsets, effectively making every read and write an aligned operation.
In <code>ReadAt</code>, it calculates the index of the chunk that the
currently read offset falls into as well as the offset within the chunk,
after which it reads the entire chunk from the backend into a buffer,
copies the requested portion of the buffer into the input slice, and
repeats the process until all requested data is read:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>totalRead <span class="op">:=</span> <span class="dv">0</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>remaining <span class="op">:=</span> <span class="bu">len</span><span class="op">(</span>p<span class="op">)</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>buf <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> a<span class="op">.</span>chunkSize<span class="op">)</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Repeat until all chunks that need to be fetched have been fetched</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> remaining <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculating the chunk and offset within the chunk</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>    chunkIndex <span class="op">:=</span> off <span class="op">/</span> a<span class="op">.</span>chunkSize</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>    indexedOffset <span class="op">:=</span> off <span class="op">%</span> a<span class="op">.</span>chunkSize</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    readSize <span class="op">:=</span> <span class="dt">int64</span><span class="op">(</span>min<span class="op">(</span>remaining<span class="op">,</span> <span class="dt">int</span><span class="op">(</span>a<span class="op">.</span>chunkSize<span class="op">-</span>indexedOffset<span class="op">)))</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reading from the next `ReadWriterAt` in the pipeline</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    _<span class="op">,</span> err <span class="op">:=</span> a<span class="op">.</span>backend<span class="op">.</span>ReadAt<span class="op">(</span>buf<span class="op">,</span> chunkIndex<span class="op">*</span>a<span class="op">.</span>chunkSize<span class="op">)</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">copy</span><span class="op">(</span>p<span class="op">[</span>totalRead<span class="op">:],</span> buf<span class="op">[</span>indexedOffset<span class="op">:</span>indexedOffset<span class="op">+</span>readSize<span class="op">])</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>    remaining <span class="op">-=</span> <span class="dt">int</span><span class="op">(</span>readSize<span class="op">)</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The writer is implemented in a similar way; it starts by calculating
the chunk and offset within the chunk. If an entire chunk is being
written to at an aligned offset, it completely bypasses the chunking
system, and writes the data directly to the backend so as to prevent
unnecessary copies:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Calculating the chunk and offset within the chunk</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>chunkIndex <span class="op">:=</span> off <span class="op">/</span> a<span class="op">.</span>chunkSize</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>indexedOffset <span class="op">:=</span> off <span class="op">%</span> a<span class="op">.</span>chunkSize</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>writeSize <span class="op">:=</span> <span class="dt">int</span><span class="op">(</span>min<span class="op">(</span>remaining<span class="op">,</span> <span class="dt">int</span><span class="op">(</span>a<span class="op">.</span>chunkSize<span class="op">-</span>indexedOffset<span class="op">)))</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Full chunk is covered by the write request, no need to read</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> indexedOffset <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> writeSize <span class="op">==</span> <span class="dt">int</span><span class="op">(</span>a<span class="op">.</span>chunkSize<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    _<span class="op">,</span> err <span class="op">=</span> a<span class="op">.</span>backend<span class="op">.</span>WriteAt<span class="op">(</span>p<span class="op">[</span>totalWritten<span class="op">:</span>totalWritten<span class="op">+</span>writeSize<span class="op">],</span> chunkIndex<span class="op">*</span>a<span class="op">.</span>chunkSize<span class="op">)</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>If this is not the case, and only parts of a chunk need to be
written, it first reads the complete chunk into a buffer, modifies the
buffer with the data that was changed, and then writes the entire buffer
back until all data has been written:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Read the existing chunk</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>_<span class="op">,</span> err <span class="op">=</span> a<span class="op">.</span>backend<span class="op">.</span>ReadAt<span class="op">(</span>buf<span class="op">,</span> chunkIndex<span class="op">*</span>a<span class="op">.</span>chunkSize<span class="op">)</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Modify the chunk with the provided data</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="bu">copy</span><span class="op">(</span>buf<span class="op">[</span>indexedOffset<span class="op">:],</span> p<span class="op">[</span>totalWritten<span class="op">:</span>totalWritten<span class="op">+</span>writeSize<span class="op">])</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Write back the updated chunk</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>_<span class="op">,</span> err <span class="op">=</span> a<span class="op">.</span>backend<span class="op">.</span>WriteAt<span class="op">(</span>buf<span class="op">,</span> chunkIndex<span class="op">*</span>a<span class="op">.</span>chunkSize<span class="op">)</span></span></code></pre></div>
<p>This simple implementation can be used to efficiently allow reading
and writing data of arbitrary length at arbitrary offsets, even if the
backend only supports aligned reads and writes.</p>
<p>In addition to this chunking system, there is also a
<code>ChunkedReadWriterAt</code>, which ensures that the limits
concerning a backend’s maximum chunk size and aligned reads/writes are
being respected. Some backends, i.e. a backend where each chunk is
represented by a file, might only support writing to aligned offsets,
but don’t support checking for this behavior; in this example, if a
chunk with a larger chunk size is written to the backend, depending on
the implementation, this could result in this chunk file’s size being
extended, which could lead to a DoS attack vector. It can also be of
relevance if a client instead of a server is expected to implement
chunking, and the server should simply enforce that the aligned reads
and writes are being provided.</p>
<p>In order to check if a read or write is aligned, this
<code>ReadWriterAt</code> checks whether an operation is done to an
offset that is multiples of the chunk size, and whether the length of
the slice of data is a valid chunk size:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Check if provided data is valid</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> off<span class="op">%</span>c<span class="op">.</span>chunkSize <span class="op">!=</span> <span class="dv">0</span> <span class="op">||</span> <span class="dt">int64</span><span class="op">(</span><span class="bu">len</span><span class="op">(</span>p<span class="op">))</span> <span class="op">!=</span> c<span class="op">.</span>chunkSize <span class="op">{</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">,</span> ErrInvalidOffset</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Check if offset is valid</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> off <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> off <span class="op">&gt;=</span> <span class="dt">int64</span><span class="op">(</span>c<span class="op">.</span>chunkSize<span class="op">*</span>c<span class="op">.</span>chunks<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">,</span> ErrInvalidReadSize</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Continues with the operation</span></span></code></pre></div>
</section>
<section id="background-pull" data-number="0.4.5.3">
<h4 data-number="1.4.5.3"><span class="header-section-number">1.4.5.3</span> Background Pull</h4>
<p>The <code>Puller</code> component asynchronously pulls chunks in the
background. It starts by sorting the chunks with the pull heuristic
mentioned earlier, after which it starts a fixed number of worker
threads in the background, each which ask for a chunk to pull:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Sort the chunks according to the pull priority callback</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>sort<span class="op">.</span>Slice<span class="op">(</span>chunkIndexes<span class="op">,</span> <span class="kw">func</span><span class="op">(</span>a<span class="op">,</span> b <span class="dt">int</span><span class="op">)</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pullPriority<span class="op">(</span>chunkIndexes<span class="op">[</span>a<span class="op">])</span> <span class="op">&gt;</span> pullPriority<span class="op">(</span>chunkIndexes<span class="op">[</span>b<span class="op">])</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">{</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get the next chunk</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    chunk <span class="op">:=</span> p<span class="op">.</span>getNextChunk<span class="op">()</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Exit after all chunks have been pulled</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> chunk <span class="op">&gt;=</span> p<span class="op">.</span>chunks <span class="op">{</span></span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reading the chunk from the backend</span></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>    _<span class="op">,</span> err <span class="op">:=</span> p<span class="op">.</span>backend<span class="op">.</span>ReadAt<span class="op">(</span><span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> p<span class="op">.</span>chunkSize<span class="op">),</span> chunkIndex<span class="op">*</span>p<span class="op">.</span>chunkSize<span class="op">)</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note that the puller itself does not copy any data from the
destination; this is handled by a separate component. It simply reads
from the next provided pipeline stage, which is expected to handle the
actual copying process.</p>
<p>An implementation of this stage is the
<code>SyncedReadWriterAt</code>, which takes both a remote and local
<code>ReadWriterAt</code> pipeline stage as it’s argument. If a chunk is
read, i.e. by the puller component calling <code>ReadAt</code>, it is
tracked and marked as remote by adding it to a local map. The chunk
itself is then read from the remote reader and written to the local one,
after which it is marked as locally available, meaning that on the
second read it is fetched from the faster, local reader instead; a
callback is used to make it possible to track the syncer’s pull
progress:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Track chunk</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>chk <span class="op">:=</span> c<span class="op">.</span>getOrTrackChunk<span class="op">(</span>off<span class="op">)</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co">// If chunk is available locally, return it</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> chk<span class="op">.</span>local <span class="op">{</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c<span class="op">.</span>local<span class="op">.</span>ReadAt<span class="op">(</span>p<span class="op">,</span> off<span class="op">)</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="co">// If chunk is not available locally, copy it from the remote, then mark the chunk as local</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>c<span class="op">.</span>remote<span class="op">.</span>ReadAt<span class="op">(</span>p<span class="op">,</span> off<span class="op">)</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>c<span class="op">.</span>local<span class="op">.</span>WriteAt<span class="op">(</span>p<span class="op">,</span> off<span class="op">)</span></span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>chk<span class="op">.</span>local <span class="op">=</span> <span class="ot">true</span></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable progress tracking</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>c<span class="op">.</span>onChunkIsLocal<span class="op">(</span>off<span class="op">)</span></span></code></pre></div>
<p>Note that since this is a pipeline stage, this behavior also applies
to reads that happen aside from those initiated by the
<code>Puller</code>, meaning that any chunks that haven’t been fetched
asynchronously before they are being accessed will be scheduled to be
pulled immediately. The <code>WriteAt</code> implementation of this
stage immediately marks and reports the chunk as available locally no
matter whether it has been pulled before or not.</p>
<p>The combination of the <code>SyncedReadWriterAt</code> stage and the
<code>Puller</code> component implements a pre-copy migration system in
an independently unit testable way, where the remote ressource is being
pre-emptively copied to the destination system first. In addition to
this however, since it can also schedule chunks to be available
immediately, it has some of the characteristics of a post-copy migration
system, too, where it is possible to fetch chunks as they become
available, making it behave similarly to the <code>rr+</code>
prefetching mechanism mentioned in “Remote Regions”<span class="citation" data-cites="aguilera2018remoteregions">[47]</span>.
Using this combination, it is possible to implement the full read-only
managed mount API.</p>
</section>
<section id="background-push" data-number="0.4.5.4">
<h4 data-number="1.4.5.4"><span class="header-section-number">1.4.5.4</span> Background Push</h4>
<p>In order to also allow for writes back to the remote source host, the
background push component exists. Once it has been opened, it schedules
recurring writebacks to the remote by calling <code>Sync</code>; once
this is called by either the background worker system or another
component, it launces writeback workers in the background. These wait to
receive a chunk that needs to be written back; once they receive one,
they read it from the local <code>ReadWriterAt</code> and copy it to the
remote, after which the chunk is marked as no longer requiring
writebacks:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Wait until the worker gets a slot from a semaphore</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>p<span class="op">.</span>workerSem <span class="op">&lt;-</span> <span class="kw">struct</span><span class="op">{}{}</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co">// First fetch from local ReaderAt, then copy to remote one</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>b <span class="op">:=</span> <span class="bu">make</span><span class="op">([]</span><span class="dt">byte</span><span class="op">,</span> p<span class="op">.</span>chunkSize<span class="op">)</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>p<span class="op">.</span>local<span class="op">.</span>ReadAt<span class="op">(</span>b<span class="op">,</span> off<span class="op">)</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>p<span class="op">.</span>remote<span class="op">.</span>WriteAt<span class="op">(</span>b<span class="op">,</span> off<span class="op">)</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="co">// Remove the chunk from the writeback queue</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a><span class="bu">delete</span><span class="op">(</span>p<span class="op">.</span>changedOffsets<span class="op">,</span> off<span class="op">)</span></span></code></pre></div>
<p>In order to prevent chunks from being pushed back to the remote
before they have been been pulled first or written to locally, the
background push system is integrated into the
<code>SyncedReadWriterAt</code> component. This is made possible by
intercepting the offset passed to the progress callback, and only then
marking it as ready:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>chunks<span class="op">.</span>NewSyncedReadWriterAt<span class="op">(</span>m<span class="op">.</span>remote<span class="op">,</span> local<span class="op">,</span> <span class="kw">func</span><span class="op">(</span>off <span class="dt">int64</span><span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> local<span class="op">.(*</span>chunks<span class="op">.</span>Pusher<span class="op">).</span>MarkOffsetPushable<span class="op">(</span>off<span class="op">)</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span></code></pre></div>
<p>Unlike the puller component, the pusher also functions as a pipeline
step, and as such provides a <code>ReadAt</code> and
<code>WriteAt</code> implementation. While <code>ReadAt</code> is a
simple proxy forwarding the call to the next stage, <code>WriteAt</code>
marks a chunk as pushable, causing it to be written back to the remote
on the next writeback cycle, before writing the chunk to the next stage.
If a managed mount is intended to be read-only, the pusher is simply not
included in the pipeline.</p>
</section>
<section id="pipeline" data-number="0.4.5.5">
<h4 data-number="1.4.5.5"><span class="header-section-number">1.4.5.5</span> Pipeline</h4>
<p>For the direct mount system, the NBD server was connected directly to
the remote; managed mounts on the other hand have an internal pipeline
of pullers, pushers, a syncer, local and remote backends as well as a
chunking system:</p>
<p>TODO: Add graphic of the internal pipeline and how systems are
connected to each other</p>
<p>Using such a pipeline system of independent stages and other
components also makes the system very testable. To do so, instead of
providing a remote and local <code>ReadWriterAt</code> at the source and
drain of the pipeline respectively, a simple in-memory or on-disk
backend can be used in the unit tests. This makes the individual
components unit-testable on their own, as well as making it possible to
test and benchmark edge cases (such as reads that are smaller than a
chunk size) and optimizations (like different pull heuristics) without
complicated setup or teardown procedures, and without having to
initialize the complete pipeline.</p>
</section>
<section id="concurrent-device-initialization" data-number="0.4.5.6">
<h4 data-number="1.4.5.6"><span class="header-section-number">1.4.5.6</span> Concurrent Device
Initialization</h4>
<p>The background push/pull components allow pulling from the remote
pipeline stage before the NBD device itself is open. This is possible
because the device doesn’t need to start accessing the data in a
post-copy sense to start the pull, and means that the pull process can
be started as the NBD client and server are still initializing. Both
components typically start quickly, but the initialization might still
take multiple milliseconds. Often, this amounts to roughly one RTT,
meaning that making this initialization procedure concurrent can
signficantly reduce the initial read latency by pre-emptively pulling
data. This is because even if the first chunks are being accessed right
after the device has been started, they are already available to be read
from the local backend instead of the remote, since they have been
pulled during the initialization and thus before the mount has even been
made available to application.</p>
</section>
<section id="device-lifecycles" data-number="0.4.5.7">
<h4 data-number="1.4.5.7"><span class="header-section-number">1.4.5.7</span> Device Lifecycles</h4>
<p>Similarly to how the direct mount API used the basic path mount to
build the file and slice mounts, the managed mount API provides the same
interfaces. In the case of managed mounts however, this is even more
important, since the synchronization lifecycle needs to be taken into
account. For example, in order to allow the <code>Sync()</code> API to
work, the <code>mmap</code>ed region must be <code>msync</code>ed before
the <code>SyncedReadWriterAt</code>’s <code>Sync()</code> method is
called. In order to support these flows without tightly coupling the
individual pipeline stages, a hooks system exists that allows for such
actions to be registered from the managed mount, which is also used to
implement the correct lifecycle for closing/tearing down a mount:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> ManagedMountHooks <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    OnBeforeSync <span class="kw">func</span><span class="op">()</span> <span class="dt">error</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    OnBeforeClose <span class="kw">func</span><span class="op">()</span> <span class="dt">error</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>    OnChunkIsLocal <span class="kw">func</span><span class="op">(</span>off <span class="dt">int64</span><span class="op">)</span> <span class="dt">error</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="wan-optimization" data-number="0.4.5.8">
<h4 data-number="1.4.5.8"><span class="header-section-number">1.4.5.8</span> WAN Optimization</h4>
<p>While the managed mount system functions as a hybrid pre- and
post-copy system, optimizations are implemented that make it more viable
in a WAN scenario compared to a typical pre-copy system by using a
unidirectional API. Usually, a pre-copy system pushes changes to the
destination host. In many WAN scenarios however, NATs prevent a direct
connection. Moreover, since the source host needs to keep track of which
chunks have already been pulled, the system becomes stateful on the
source host and events such as network outages need to be recoverable
from.</p>
<p>By using the pull-only, unidirectional API to emulate the pre-copy
setup, the destination can simply keep track of which chunks it still
needs to pull itself, meaning that if there is a network outage, it can
just resume pulling or decide to restart the pre-copy process. Unlike
the pre-copy system used for the file synchronization/hashing approach,
this also means that destination hosts don’t need to subscribe to a
central multiplexing hub, and adding clients to the topology is easy
since their pull progress state does not need to be stored anywhere
except the destination node.</p>
</section>
</section>
<section id="live-migration" data-number="0.4.6">
<h3 data-number="1.4.6"><span class="header-section-number">1.4.6</span>
Live Migration</h3>
<section id="overview-3" data-number="0.4.6.1">
<h4 data-number="1.4.6.1"><span class="header-section-number">1.4.6.1</span> Overview</h4>
<p>As mentioned in Pull-Based Synchronization with Migrations earlier,
the mount API is not optimal for a migration scenario. Splitting the
migration into two discrete phases can help fix the biggest problem, the
maximum guaranteed downtime; thanks to the flexible pipeline system of
<code>ReadWriterAt</code>s, a lot of the code from the mount API can be
reused for the migration, even if the API and corresponding wire
protocol are different.</p>
</section>
<section id="seeder" data-number="0.4.6.2">
<h4 data-number="1.4.6.2"><span class="header-section-number">1.4.6.2</span> Seeder</h4>
<p>The seeder defines a new read-only RPC API, which, in addition the
known <code>ReadAt</code>, also adds new RPCs such as <code>Sync</code>,
which is extended to return dirty chunks, as well as
<code>Track()</code>, which triggers a new tracking stage:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> SeederRemote <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    ReadAt <span class="kw">func</span><span class="op">(</span>context context<span class="op">.</span>Context<span class="op">,</span> length <span class="dt">int</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>r ReadAtResponse<span class="op">,</span> err <span class="dt">error</span><span class="op">)</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    Size   <span class="kw">func</span><span class="op">(</span>context context<span class="op">.</span>Context<span class="op">)</span> <span class="op">(</span><span class="dt">int64</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    Track  <span class="kw">func</span><span class="op">(</span>context context<span class="op">.</span>Context<span class="op">)</span> <span class="dt">error</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    Sync   <span class="kw">func</span><span class="op">(</span>context context<span class="op">.</span>Context<span class="op">)</span> <span class="op">([]</span><span class="dt">int64</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    Close  <span class="kw">func</span><span class="op">(</span>context context<span class="op">.</span>Context<span class="op">)</span> <span class="dt">error</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unlike the remote backend, the seeder also exposes a mount through
the familiar path, file or slice APIs, meaning that even as the
migration is in progress, the underlying ressource can still be accessed
by the application on the source host. This fixes the architectural
constraint of the mount API when used for the migration, where only the
destination is able to expose a mount, while the source simply serves
data without accessing it.</p>
<p>The tracking support is imlement in the same modular and composable
way as the syncer, by providing a new pipeline stage, the
<code>TrackingReadWriter</code>. Once activated by the
<code>Track</code> RPC, the tracker intecepts all <code>WriteAt</code>
calls and adds them to a local map before calling the next stage.:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">// If tracking is enabled, mark the chunk as dirty</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> c<span class="op">.</span>tracking <span class="op">{</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span>dirtyOffsetsIndex<span class="op">[</span>off<span class="op">]</span> <span class="op">=</span> <span class="kw">struct</span><span class="op">{}{}</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Call the next stage</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> c<span class="op">.</span>backend<span class="op">.</span>WriteAt<span class="op">(</span>p<span class="op">,</span> off<span class="op">)</span></span></code></pre></div>
<p>Once the <code>Sync</code> RPC is called by the destination host,
these dirty offsets are returned and the map is cleared:</p>
<p>TODO: Add graphic of the pipeline’s design</p>
<p>A benefit of the protocol being defined in such a way that only the
client ever calls an RPC, thus making the protocol uni-directional, is
that both the transport layer and RPC system are completely
interchangeable. This works by returning a simple abstract
<code>service</code> utility struct from <code>Open</code>, which can
then be used as the implementation for any RPC framework, i.e. with the
actual gRPC service simply functioning as an adapter:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> SeederGrpc <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    v1<span class="op">.</span>UnimplementedSeederServer</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    svc <span class="op">*</span>Seeder</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>SeederGrpc<span class="op">)</span> ReadAt<span class="op">(</span>ctx context<span class="op">.</span>Context<span class="op">,</span> args <span class="op">*</span>v1<span class="op">.</span>ReadAtArgs<span class="op">)</span> <span class="op">(*</span>v1<span class="op">.</span>ReadAtReply<span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>    res<span class="op">,</span> err <span class="op">:=</span> s<span class="op">.</span>svc<span class="op">.</span>ReadAt<span class="op">(</span>ctx<span class="op">,</span> <span class="dt">int</span><span class="op">(</span>args<span class="op">.</span>GetLength<span class="op">()),</span> args<span class="op">.</span>GetOff<span class="op">())</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>v1<span class="op">.</span>ReadAtReply<span class="op">{</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>        N<span class="op">:</span> <span class="dt">int32</span><span class="op">(</span>res<span class="op">.</span>N<span class="op">),</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>        P<span class="op">:</span> res<span class="op">.</span>P<span class="op">,</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span> <span class="ot">nil</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="leecher" data-number="0.4.6.3">
<h4 data-number="1.4.6.3"><span class="header-section-number">1.4.6.3</span> Leecher</h4>
<p>The leecher then takes this abstract service struct provided by the
seeder, which is implemented by a RPC framework. Using this, as soon as
the leecher is opened, it calls <code>Track()</code> in the background
and starts the NBD device in parallel to achieve a similar reduction in
initial read latency as the mount API. The leecher introduces a new
pipeline stage, the <code>LockableReadWriterAt</code>:</p>
<p>TODO: Add graphic of pipeline design</p>
<p>This component simply blocks all read and write operations to/from
the NBD device until <code>Finalize</code> has been called by using a
<code>sync.Cond</code>. This is required becaused otherwise, stale data
(before <code>Finalize</code> marked the chunks as dirty) could have
poisoned the kernel’s file cache if the application read data before
finalization:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co">// For `ReadAt/WriteAt`: Waits for finalization, then calls the actual read/write operation</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>a<span class="op">.</span>lock<span class="op">.</span>L<span class="op">.</span>Lock<span class="op">()</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> a<span class="op">.</span>locked <span class="op">{</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>lock<span class="op">.</span>Wait<span class="op">()</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>a<span class="op">.</span>lock<span class="op">.</span>L<span class="op">.</span>Unlock<span class="op">()</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Unlocks the `sync.Cond` and broadcasts the new unlocked state to all previously blocked `ReadAt`/`WriteAt` operations</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>a <span class="op">*</span>LockableReadWriterAt<span class="op">)</span> Unlock<span class="op">()</span> <span class="op">{</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>lock<span class="op">.</span>L<span class="op">.</span>Lock<span class="op">()</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>locked <span class="op">=</span> <span class="ot">false</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>lock<span class="op">.</span>Broadcast<span class="op">()</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>    a<span class="op">.</span>lock<span class="op">.</span>L<span class="op">.</span>Unlock<span class="op">()</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Once the leecher has started the device, it sets up a syncer in the
same way as the mount API. A callback can again be used to monitor the
pull progress, and once the reported availability is satisfactory,
<code>Finalize</code> can be called. This then handles the critical
migration phase, in which the remote application consuming the resource
must be suspended; to do this, <code>Finalize</code> calls
<code>Sync</code> on the seeder, causing it to return the dirty chunks
and suspending the remote application, while the leecher marks the dirty
chunks as remote and schedules them to be pulled immediately in the
background to optimize for temporal locality:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Suspends the remote application, flushes the mount and returns offsets that have been written too since `Track()`</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>dirtyOffsets<span class="op">,</span> err <span class="op">:=</span> l<span class="op">.</span>remote<span class="op">.</span>Sync<span class="op">(</span>l<span class="op">.</span>ctx<span class="op">)</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Marks the chunks as remote, causing subsequent reads to pull them again</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>l<span class="op">.</span>syncedReadWriter<span class="op">.</span>MarkAsRemote<span class="op">(</span>dirtyOffsets<span class="op">)</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="co">// Schedules the chunks to be pulled in the background immediately</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>l<span class="op">.</span>puller<span class="op">.</span>Finalize<span class="op">(</span>dirtyOffsets<span class="op">)</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a><span class="co">// Unlocks the local ressource for reading</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>l<span class="op">.</span>lockableReadWriterAt<span class="op">.</span>Unlock<span class="op">()</span></span></code></pre></div>
<p>As an additional measure aside from the lockable
<code>ReadWriterAt</code> is to make accessing the mount too earlier
than after finalization harder, since only <code>Finalize</code> returns
the mount, meaning that the API can’t easily lead to deadlocks between
<code>Finalize</code> and accessing the mount.</p>
<p>After the leecher has successfully reached 100% availability, it
calls <code>Close</code> on the seeder and disconnects the leecher,
causing both to shut down, after which the leecher can re-use the mount
to provide a new seeder which can allow further migrations to happen in
the same way.</p>
</section>
</section>
<section id="pluggable-encryption-authentication-and-transport" data-number="0.4.7">
<h3 data-number="1.4.7"><span class="header-section-number">1.4.7</span>
Pluggable Encryption, Authentication and Transport</h3>
<p>Compared to existing remote memory and migration solutions, r3map is
designed for a new field of application: WAN. Most existing systems that
provide these solutions are intended to work in high-throughput,
low-latency LAN, where assumptions concerning authentication and
authorization as well as scalability can be made that are not valid in a
WAN deployment. For example encryption: While in trusted LAN networks,
it can be a viable option to assume that there are no bad actors in the
local subnet, the same can not be assumed for WAN. While depending on
i.e. TLS for the APIs would have been a viable option for r3map if it
were to only support WAN deployments, it should still be functional and
be able to take advantage of the guarantees if it is deployed in a LAN,
which is why it is transport agnostic.</p>
<p>This makes adding guarantees such as encryption as simple as choosing
the best solution depending on the network conditions. For low-latency,
trusted networks, a protocol like the SCSI RDMA protocol (SRP) can be
chosen, while for WAN, a standard internet protocol like TLS over TCP or
QUIC can be used instead. Similarly to how the transport layer is
interchangable, it is RPC-framework independent as well. This means that
RPC frameworks such as dudirekta (which will be elaborated on later),
which can work over P2P protocols like WebRTC data channels, are an
option for environments with highly dynamic network topologies, where IP
addresses rotate or there might be temporary loss of connectivity to
recover from, as is the case with i.e. mobile networks, allowing live
migration to work in completely new environments.</p>
<p>Since r3map makes no assumptions about them, authentication and
authorization can be implemented in a similar way. For LAN deployments,
the typical approach of simply trusting the local subnet can be used,
for public deployments mTLS certificates or dedicated authentication
protocols like OIDC can be an option. In networks with high RTT, QUIC
allows the use of a 0-RTT handshake, which combines the connectivity and
security handshake into one; this paired with mTLS can be an interesting
option to decrease the initial read latency while still providing proper
authentication.</p>
</section>
<section id="concurrent-backends" data-number="0.4.8">
<h3 data-number="1.4.8"><span class="header-section-number">1.4.8</span>
Concurrent Backends</h3>
<p>In high-RTT scenarios, the ability to fetch chunks concurrently is
important. Without concurrent backgrounds pulls, latency can add up
quickly, since every read to an offset of the memory region would have
at least one RTT as it’s latency, while concurrent pulls allow for
multiple offsets’ chunks to be pulled at the same time.</p>
<p>The first requirement for supporting this is that the remote backend
has to be able to read from multiple regions without globally locking
it. For the file backend for example, this is not the case, as a lock
needs to be acquired for the entire file before an offset can be
accessed:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>FileBackend<span class="op">)</span> ReadAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>lock<span class="op">.</span>RLock<span class="op">()</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">defer</span> b<span class="op">.</span>lock<span class="op">.</span>RUnlock<span class="op">()</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    n<span class="op">,</span> err <span class="op">=</span> b<span class="op">.</span>file<span class="op">.</span>ReadAt<span class="op">(</span>p<span class="op">,</span> off<span class="op">)</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This can quickly become a bottleneck in the pipeline. One option that
tries to solve this is the directory backend; instead of using just one
backing file, the directory backend is a chunked backend that uses a
directory of files, with each file representing a chunk. By using
multiple files, this backend can lock each file (and thus chunk)
individually, speeding up concurrent access. The same also applies to
writees, where even concurrent writes to different chunks can safely be
done at the same time as they are all backend by a separate file. This
backend keeps track of these chunks by using an internal map of locks,
and a queue to keep track of the order in which chunks’ corresponding
files were opened; when a chunk is first accessed, a new file is created
for the chunk, and if the first operation is <code>ReadAt</code>, it is
also truncated to exactly one chunk length. In order not to exceed the
maximum number of open files for the backend process, a simple LRU
algorithm is used to to close an open file if the limit would be
exceeded:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Open files limit exceedd</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="dt">int64</span><span class="op">(</span><span class="bu">len</span><span class="op">(</span>b<span class="op">.</span>filesQueue<span class="op">))</span> <span class="op">==</span> b<span class="op">.</span>maxOpenFiles <span class="op">{</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Find the least recently used offset and corresponding file</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    lruOff <span class="op">:=</span> b<span class="op">.</span>filesQueue<span class="op">[</span><span class="dv">0</span><span class="op">]</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    lruFl <span class="op">:=</span> b<span class="op">.</span>files<span class="op">[</span>lruOff<span class="op">]</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Close and nil it</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> lruFl<span class="op">.</span>file <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> err <span class="op">:=</span> lruFl<span class="op">.</span>file<span class="op">.</span>Close<span class="op">();</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="ot">nil</span><span class="op">,</span> err</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>        lruFl<span class="op">.</span>file <span class="op">=</span> <span class="ot">nil</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Remove it from the list and map of open files</span></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">delete</span><span class="op">(</span>b<span class="op">.</span>files<span class="op">,</span> lruOff<span class="op">)</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>filesQueue <span class="op">=</span> b<span class="op">.</span>filesQueue<span class="op">[</span><span class="dv">1</span><span class="op">:]</span></span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="remote-stores-as-backends" data-number="0.4.9">
<h3 data-number="1.4.9"><span class="header-section-number">1.4.9</span>
Remote Stores as Backends</h3>
<section id="overview-4" data-number="0.4.9.1">
<h4 data-number="1.4.9.1"><span class="header-section-number">1.4.9.1</span> Overview</h4>
<p>RPC backends provide a dynamic way to access a remote backend. This
is useful for lots of usecases, esp. if the backend exposes a custom
ressource or requires custom authorization or caching. For the mount API
specifically however, having access to a remote backend that doesn’t
require a custom RPC system can be useful, since the backend for a
remote mount maps fairly well to the concept of a remote random-access
storage device, for which many protocols and systems exist already.</p>
</section>
<section id="key-value-stores-with-redis" data-number="0.4.9.2">
<h4 data-number="1.4.9.2"><span class="header-section-number">1.4.9.2</span> Key-Value Stores with
Redis</h4>
<p>On such option is Redis, an in-memory key-value store with network
access. To implement a mount backend, chunk offses can be mapped to
keys, and since bytes are a valid key type, the chunk itself can be
stored directly in the KV store; if keys don’t exist, they are simply
treated as empty chunks:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>RedisBackend<span class="op">)</span> ReadAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Retrieve a key corresponding to the chunk from Redis</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>    val<span class="op">,</span> err <span class="op">:=</span> b<span class="op">.</span>client<span class="op">.</span>Get<span class="op">(</span>b<span class="op">.</span>ctx<span class="op">,</span> strconv<span class="op">.</span>FormatInt<span class="op">(</span>off<span class="op">,</span> <span class="dv">10</span><span class="op">)).</span>Bytes<span class="op">()</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If  a key does not exist, treat it as an empty chunk</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">==</span> redis<span class="op">.</span>Nil <span class="op">{</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span><span class="op">(</span>p<span class="op">),</span> <span class="ot">nil</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>RedisBackend<span class="op">)</span> WriteAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Store an offset as a key-value pair in Redis</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>client<span class="op">.</span>Set<span class="op">(</span>b<span class="op">.</span>ctx<span class="op">,</span> strconv<span class="op">.</span>FormatInt<span class="op">(</span>off<span class="op">,</span> <span class="dv">10</span><span class="op">),</span> p<span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Using Redis is particularly interesting because it is able to handle
locking the indiviudal chunks server-side in an efficient way, and
thanks to it’s custom protocol and fast serialization it is well-suited
for high-throughput deployment scenarios. Authentication and
authorization for this backend can be handled using the Redis protocol,
and hosting multiple memory regions can be implemented by using multiple
databases or key prefixes.</p>
</section>
<section id="object-stores-with-s3" data-number="0.4.9.3">
<h4 data-number="1.4.9.3"><span class="header-section-number">1.4.9.3</span> Object Stores with S3</h4>
<p>While Redis is interesting for high-throughput scenarios, when it
comes to making a memory region available on the public internet, it
might not be the best choice due to it’s low-level, custom protocol and
(mostly) in-memory nature. This is where S3 can be used; a S3 backend
can be a good choice for mounting public information, i.e. media assets,
binaries, large filesystems and more into memory. While S3 has
traditionally been mostly a AWS SaaS offering, projects such as Minio
have helped it become the de facto standard for accessing files over
HTTP. Similarly to the directory backend, the S3 backend is chunked,
with one S3 object representing one chunk; if accessing a chunk returns
a 404 error, it is treated as an empty chunk in the same way as the
Redis backend, and multi-tenancy can once again be implemented either by
using multiple S3 buckets or a prefix:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>S3Backend<span class="op">)</span> ReadAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Receiving a chunk using Minio&#39;s S3 client</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>    obj<span class="op">,</span> err <span class="op">:=</span> b<span class="op">.</span>client<span class="op">.</span>GetObject<span class="op">(</span>b<span class="op">.</span>bucket<span class="op">,</span> b<span class="op">.</span>prefix<span class="op">+</span><span class="st">&quot;-&quot;</span><span class="op">+</span>strconv<span class="op">.</span>FormatInt<span class="op">(</span>off<span class="op">,</span> <span class="dv">10</span><span class="op">),</span> minio<span class="op">.</span>GetObjectOptions<span class="op">{})</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If an object is not found, it is treated as an empty chunk</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> err<span class="op">.</span>Error<span class="op">()</span> <span class="op">==</span> errNoSuchKey<span class="op">.</span>Error<span class="op">()</span> <span class="op">{</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">len</span><span class="op">(</span>p<span class="op">),</span> <span class="ot">nil</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  ...</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="document-databases-with-cassandra" data-number="0.4.9.4">
<h4 data-number="1.4.9.4"><span class="header-section-number">1.4.9.4</span> Document Databases with
Cassandra</h4>
<p>Another option to access persistent remote ressource is a NoSQL
database such as Cassandra, specifically ScyllaDB, which improves on
Cassandra’s latency, a key metric for mounting remote resources. While
this backend is more of a proof of concept rather than a real usecase,
it does show that even a database can be mapped to a memory region,
which does allow for the interesting usecase of making the databases’
contents available directly in memory without having to use a
database-specific client. Here, <code>ReadAt</code> and
<code>WriteAt</code> are implemented by issues queries through
Cassandra’s DSL, where each row represents a chunk identified by it’s
offset as the primary, and as with Redis and S3, non-existing rows are
treated as empty chunks:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>CassandraBackend<span class="op">)</span> ReadAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Executing a select query for a specific chunk, then scanning it into a byte slice</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> val <span class="op">[]</span><span class="dt">byte</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">:=</span> b<span class="op">.</span>session<span class="op">.</span>Query<span class="op">(</span><span class="st">`select data from `</span><span class="op">+</span>b<span class="op">.</span>table<span class="op">+</span><span class="st">` where key = ? limit 1`</span><span class="op">,</span> b<span class="op">.</span>prefix<span class="op">+</span><span class="st">&quot;-&quot;</span><span class="op">+</span>strconv<span class="op">.</span>FormatInt<span class="op">(</span>off<span class="op">,</span> <span class="dv">10</span><span class="op">)).</span>Scan<span class="op">(&amp;</span>val<span class="op">);</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> err <span class="op">==</span> gocql<span class="op">.</span>ErrNotFound <span class="op">{</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">len</span><span class="op">(</span>p<span class="op">),</span> <span class="ot">nil</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">,</span> err</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>CassandraBackend<span class="op">)</span> WriteAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Upserting a row with a chunk&#39;s new content</span></span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>session<span class="op">.</span>Query<span class="op">(</span><span class="st">`insert into `</span><span class="op">+</span>b<span class="op">.</span>table<span class="op">+</span><span class="st">` (key, data) values (?, ?)`</span><span class="op">,</span> b<span class="op">.</span>prefix<span class="op">+</span><span class="st">&quot;-&quot;</span><span class="op">+</span>strconv<span class="op">.</span>FormatInt<span class="op">(</span>off<span class="op">,</span> <span class="dv">10</span><span class="op">),</span> p<span class="op">).</span>Exec<span class="op">()</span></span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Support for multiple regions can be implement by using a different
table or key prefix, and migrations are used to create the table itself
similarly to how it would be done in SQL.</p>
</section>
</section>
<section id="concurrent-bi-directional-rpcs-with-dudirekta" data-number="0.4.10">
<h3 data-number="1.4.10"><span class="header-section-number">1.4.10</span> Concurrent Bi-Directional
RPCs with Dudirekta</h3>
<section id="overview-5" data-number="0.4.10.1">
<h4 data-number="1.4.10.1"><span class="header-section-number">1.4.10.1</span> Overview</h4>
<p>Another aspect that plays an important role in performance for
real-life deployments is the choice of RPC framework and transport
protocol. As mentioned before, both the mount and migration APIs are
transport-independent, and as a result almost any RPC framework can be
used. A RPC framework developed as part of r3map is Dudireka<span class="citation" data-cites="pojtinger2023dudirekta">[48]</span>. As
such, it was designed specifically with the hybrid pre-and post-copy
scenario in mind. To optimize for this, it has support for concurrent
RPCs, which allows for efficient background pulls as multiple chunks can
be pulled at the same time.</p>
<p>The framework also allows for defining functions on both the client
and the server, which makes it possible to initiate pre-copy migratons
and transfer chnks from the source host to the destination without
having the latter be <code>dial</code>able; while making the destination
host available by dialing it is possible in trusted LAN deployments,
NATs and security concerns make it harder in WAN deployment. As part of
this bi-directional support it is possible to also pass callbacks and
closures as arguments to RPCs, which makes it possible to model remote
generators with yields to easily report i.e. a migration’s progress as
it is running, while still modelling the migration with a single,
transactional RPC and a return value. In addition to this, because
dudirekta is also itself transport-agnostic, it is possible to use
transport protocols like QUIC in WAN deployments, which can reduce the
initial latency by using the 0-RTT handshake and thus makes calling an
RPC less expensive. By not requiring TCP-style client-server semantics,
Dudirekta can also be used to allow for P2P migrations over a protocol
such as WebRTC<span class="citation" data-cites="pojtinger2023dudirektawebrtc">[49]</span>.</p>
</section>
<section id="usage" data-number="0.4.10.2">
<h4 data-number="1.4.10.2"><span class="header-section-number">1.4.10.2</span> Usage</h4>
<p>Dudirekta is reflection based; both RPC definition and calling an RPC
are completely transparent, which makes it optimal for prototyping the
mount and migration APIs. To define the RPCs to be exposed, a simple
implementation struct can be created for both the client and server. In
this example, the server provides a simple counter with an increment
RPC, while the client provides a simple <code>Println</code> RPC that
can be called from the server. Due to protocol limitations, RPCs must
have a context as their first argument, not have variadic arguments, and
must return either a single value or an error:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Server</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> local <span class="kw">struct</span> <span class="op">{</span> counter <span class="dt">int64</span> <span class="op">}</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>local<span class="op">)</span> Increment<span class="op">(</span>ctx context<span class="op">.</span>Context<span class="op">,</span> delta <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span><span class="dt">int64</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> atomic<span class="op">.</span>AddInt64<span class="op">(&amp;</span>s<span class="op">.</span>counter<span class="op">,</span> delta<span class="op">),</span> <span class="ot">nil</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Client</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> local <span class="kw">struct</span><span class="op">{}</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>local<span class="op">)</span> Println<span class="op">(</span>ctx context<span class="op">.</span>Context<span class="op">,</span> msg <span class="dt">string</span><span class="op">)</span> <span class="dt">error</span> <span class="op">{</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>    fmt<span class="op">.</span>Println<span class="op">(</span>msg<span class="op">)</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In order to call these RPCs from the client/server respectively, the
remote functions defined earlier are also created as placeholder structs
that will be implemented by Dudirekta at runtime using reflection and
are added to registry, which provides a handler that links a connection
to the RPC implementation:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Server</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> remote <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    Println <span class="kw">func</span><span class="op">(</span>ctx context<span class="op">.</span>Context<span class="op">,</span> msg <span class="dt">string</span><span class="op">)</span> <span class="dt">error</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>registry <span class="op">:=</span> rpc<span class="op">.</span>NewRegistry<span class="op">(</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>local<span class="op">{},</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    remote<span class="op">{},</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a><span class="co">// Client</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> remote <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>    Increment <span class="kw">func</span><span class="op">(</span>ctx context<span class="op">.</span>Context<span class="op">,</span> delta <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span><span class="dt">int64</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb69-16"><a href="#cb69-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-17"><a href="#cb69-17" aria-hidden="true" tabindex="-1"></a>registry <span class="op">:=</span> rpc<span class="op">.</span>NewRegistry<span class="op">(</span></span>
<span id="cb69-18"><a href="#cb69-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span>local<span class="op">{},</span></span>
<span id="cb69-19"><a href="#cb69-19" aria-hidden="true" tabindex="-1"></a>    remote<span class="op">{},</span></span>
<span id="cb69-20"><a href="#cb69-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb69-21"><a href="#cb69-21" aria-hidden="true" tabindex="-1"></a><span class="op">)</span></span></code></pre></div>
<p>This handler can then be linked to a connection provided by any
transport layer, i.e. TCP:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Server: Create a TCP listener, wait for a connection, and link it to the registry</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>lis<span class="op">,</span> err <span class="op">:=</span> net<span class="op">.</span>Listen<span class="op">(</span><span class="st">&quot;tcp&quot;</span><span class="op">,</span> <span class="st">&quot;localhost:1337&quot;</span><span class="op">)</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>conn<span class="op">,</span> err <span class="op">:=</span> lis<span class="op">.</span>Accept<span class="op">()</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>registry<span class="op">.</span>Link<span class="op">(</span>conn<span class="op">)</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Client: Connect to the TCP listener and link it to the registry</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a>conn<span class="op">,</span> err <span class="op">:=</span> net<span class="op">.</span>Dial<span class="op">(</span><span class="st">&quot;tcp&quot;</span><span class="op">,</span> <span class="op">*</span>addr<span class="op">)</span></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>registry<span class="op">.</span>Link<span class="op">(</span>conn<span class="op">)</span></span></code></pre></div>
<p>After both registries have been linked to the transport, it is
possible to call the RPCs exposed by the remote peers from both the
server and the client, which makes bi-directional communication
possible:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Server: Calls the `Println` RPC exposed by the client</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _<span class="op">,</span> peer <span class="op">:=</span> <span class="kw">range</span> registry<span class="op">.</span>Peers<span class="op">()</span> <span class="op">{</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>    peer<span class="op">.</span>Println<span class="op">(</span>ctx<span class="op">,</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">)</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Client: Calls the `Increment` RPC exposed by the server</span></span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _<span class="op">,</span> peer <span class="op">:=</span> <span class="kw">range</span> registry<span class="op">.</span>Peers<span class="op">()</span> <span class="op">{</span></span>
<span id="cb71-8"><a href="#cb71-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">new</span><span class="op">,</span> err <span class="op">:=</span> peer<span class="op">.</span>Increment<span class="op">(</span>ctx<span class="op">,</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb71-9"><a href="#cb71-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-10"><a href="#cb71-10" aria-hidden="true" tabindex="-1"></a>    log<span class="op">.</span>Println<span class="op">(</span><span class="bu">new</span><span class="op">)</span> <span class="co">// Returns the value incremented by one</span></span>
<span id="cb71-11"><a href="#cb71-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As mentioned earlier, Dudirekta also allows for passing in closures
as arguments to RPCs; since this is also handled transparently, all that
is necessary is to define the signature of the closure on the client and
server, and it can be passed in as though the RPC were a local call,
which also works on both the client and the server side:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Server</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>local<span class="op">)</span> Iterate<span class="op">(</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>    ctx context<span class="op">.</span>Context<span class="op">,</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>    length <span class="dt">int</span><span class="op">,</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>    onIteration <span class="kw">func</span><span class="op">(</span>i <span class="dt">int</span><span class="op">,</span> b <span class="dt">string</span><span class="op">)</span> <span class="op">(</span><span class="dt">string</span><span class="op">,</span> <span class="dt">error</span><span class="op">),</span> <span class="co">// Closure that is being passed in</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> <span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> length<span class="op">;</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>        rv<span class="op">,</span> err <span class="op">:=</span> onIteration<span class="op">(</span>i<span class="op">,</span> <span class="st">&quot;This is from the callee&quot;</span><span class="op">)</span> <span class="co">// Remote closure is being called</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> length<span class="op">,</span> <span class="ot">nil</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a><span class="co">// Client</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> remote <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>    Iterate <span class="kw">func</span><span class="op">(</span></span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>        ctx context<span class="op">.</span>Context<span class="op">,</span></span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>        length <span class="dt">int</span><span class="op">,</span></span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>        onIteration <span class="kw">func</span><span class="op">(</span>i <span class="dt">int</span><span class="op">,</span> b <span class="dt">string</span><span class="op">)</span> <span class="op">(</span><span class="dt">string</span><span class="op">,</span> <span class="dt">error</span><span class="op">),</span> <span class="co">// The closure is defined in the placeholder struct</span></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span> <span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span></span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _<span class="op">,</span> peer <span class="op">:=</span> <span class="kw">range</span> registry<span class="op">.</span>Peers<span class="op">()</span> <span class="op">{</span></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// `Iterate` RPC provided by the server is called</span></span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>    length<span class="op">,</span> err <span class="op">:=</span> Iterate<span class="op">(</span>peer<span class="op">,</span> ctx<span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="kw">func</span><span class="op">(</span>i <span class="dt">int</span><span class="op">,</span> b <span class="dt">string</span><span class="op">)</span> <span class="op">(</span><span class="dt">string</span><span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Closure is transparently provided as a regular argumnt</span></span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">&quot;This is from the caller&quot;</span><span class="op">,</span> <span class="ot">nil</span></span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a>    log<span class="op">.</span>Println<span class="op">(</span>length<span class="op">)</span> <span class="co">// Despite having a closure as an argument, the RPC can still return values</span></span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="protocol" data-number="0.4.10.3">
<h4 data-number="1.4.10.3"><span class="header-section-number">1.4.10.3</span> Protocol</h4>
<p>The protocol used for dudirekta is simple and based on JSONL; a
function call, i.e. to <code>Println</code> looks like this:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="ot">[</span><span class="kw">true</span><span class="ot">,</span> <span class="st">&quot;1&quot;</span><span class="ot">,</span> <span class="st">&quot;Println&quot;</span><span class="ot">,</span> <span class="ot">[</span><span class="st">&quot;Hello, world!&quot;</span><span class="ot">]]</span></span></code></pre></div>
<p>The first element marks the message as a function call, while the
second one is the call ID, the third represents the name of the RPC that
is being called followed by an array of arguments. A function return
messages looks similar:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="ot">[</span><span class="kw">false</span><span class="ot">,</span> <span class="st">&quot;1&quot;</span><span class="ot">,</span> <span class="st">&quot;&quot;</span><span class="ot">,</span> <span class="st">&quot;&quot;</span><span class="ot">]</span></span></code></pre></div>
<p>Here, the message is marked as a return value in the first element,
the ID is passed with the second element and both the actual return
value (third element) and error (fourth element) are nil and represented
by an empty sring. Because it includes IDs, this protocol allows for
concurrent RPCs through muxing and demuxing the JSONL messages.</p>
</section>
<section id="rpc-providers" data-number="0.4.10.4">
<h4 data-number="1.4.10.4"><span class="header-section-number">1.4.10.4</span> RPC Providers</h4>
<p>If an RPC (such as <code>ReadAt</code> in the case of the mount API)
is called, a method with the provided RPC’s name is looked up on the
provided implementation struct and if it is found, the provided
argument’s types are validated against those of the implementation by
unmarshalling them into their native natives:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Unmarshalling the function name and args from the protocol</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> functionName <span class="dt">string</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>json<span class="op">.</span>Unmarshal<span class="op">(</span>res<span class="op">[</span><span class="dv">2</span><span class="op">],</span> <span class="op">&amp;</span>functionName<span class="op">)</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> functionArgs <span class="op">[]</span>json<span class="op">.</span>RawMessage</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>json<span class="op">.</span>Unmarshal<span class="op">(</span>res<span class="op">[</span><span class="dv">3</span><span class="op">],</span> <span class="op">&amp;</span>functionArgs<span class="op">)</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a><span class="co">// Looking up the field on the local struct</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>function <span class="op">:=</span> reflect<span class="op">.</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>    ValueOf<span class="op">(</span>r<span class="op">.</span>local<span class="op">.</span>wrappee<span class="op">).</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>    MethodByName<span class="op">(</span>functionName<span class="op">)</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a><span class="co">// Only continue if the field can be called</span></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> function<span class="op">.</span>Kind<span class="op">()</span> <span class="op">!=</span> reflect<span class="op">.</span>Func <span class="op">{</span></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ErrCannotCallNonFunction</span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a><span class="co">// Validation of the argument count</span></span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> function<span class="op">.</span>Type<span class="op">().</span>NumIn<span class="op">()</span> <span class="op">!=</span> <span class="bu">len</span><span class="op">(</span>functionArgs<span class="op">)+</span><span class="dv">1</span> <span class="op">{</span></span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ErrInvalidArgs</span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a><span class="co">// Validation of the arguments&#39; types; if an argument can not be unmarshalled, the call is cancelled</span></span>
<span id="cb75-24"><a href="#cb75-24" aria-hidden="true" tabindex="-1"></a>args <span class="op">:=</span> <span class="op">[]</span>reflect<span class="op">.</span>Value<span class="op">{}</span></span>
<span id="cb75-25"><a href="#cb75-25" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> function<span class="op">.</span>Type<span class="op">().</span>NumIn<span class="op">();</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb75-26"><a href="#cb75-26" aria-hidden="true" tabindex="-1"></a>    functionType <span class="op">:=</span> function<span class="op">.</span>Type<span class="op">().</span>In<span class="op">(</span>i<span class="op">)</span></span>
<span id="cb75-27"><a href="#cb75-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-28"><a href="#cb75-28" aria-hidden="true" tabindex="-1"></a>    arg <span class="op">:=</span> reflect<span class="op">.</span>New<span class="op">(</span>functionType<span class="op">)</span></span>
<span id="cb75-29"><a href="#cb75-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">:=</span> json<span class="op">.</span>Unmarshal<span class="op">(</span>functionArgs<span class="op">[</span>i<span class="dv">-1</span><span class="op">],</span> arg<span class="op">.</span>Interface<span class="op">());</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb75-30"><a href="#cb75-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> err</span>
<span id="cb75-31"><a href="#cb75-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb75-32"><a href="#cb75-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-33"><a href="#cb75-33" aria-hidden="true" tabindex="-1"></a>    args <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>args<span class="op">,</span> arg<span class="op">.</span>Elem<span class="op">())</span></span>
<span id="cb75-34"><a href="#cb75-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>After the call has been validated by the RPC provider, the actual RPC
implementation is executed in a new goroutine to allow for concurrent
RPCs, the return and error value of which is then marshalled into JSON
and sent back the caller.</p>
<p>In addition to the RPCs created by analyzing the implementation
struct through reflection, to be able to support closures, a virtual
<code>CallClosure</code> RPC is also exposed. This RPC is provided by a
separate closure management component, which handles storing references
to remote closure implementations:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>m <span class="op">*</span>closureManager<span class="op">)</span> CallClosure<span class="op">(</span>ctx context<span class="op">.</span>Context<span class="op">,</span> closureID <span class="dt">string</span><span class="op">,</span> args <span class="op">[]</span><span class="kw">interface</span><span class="op">{})</span> <span class="op">(</span><span class="kw">interface</span><span class="op">{},</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Looking up a reference to the closure&#39;s implementation by it&#39;s call ID</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    closure<span class="op">,</span> ok <span class="op">:=</span> m<span class="op">.</span>closures<span class="op">[</span>closureID<span class="op">]</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calling the closure</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> closure<span class="op">(</span>args<span class="op">...)</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It also garbage collects those references after a RPC that has
provided a closure has returned:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co">// If a closure is provided as an argument, handle it differently</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> arg<span class="op">.</span>Kind<span class="op">()</span> <span class="op">==</span> reflect<span class="op">.</span>Func <span class="op">{</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    closureID<span class="op">,</span> freeClosure<span class="op">,</span> err <span class="op">:=</span> registerClosure<span class="op">(</span>r<span class="op">.</span>local<span class="op">.</span>wrapper<span class="op">,</span> arg<span class="op">.</span>Interface<span class="op">())</span></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Freeing the closure after the RPC that has provided it is out of scope</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">defer</span> freeClosure<span class="op">()</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>    cmdArgs <span class="op">=</span> <span class="bu">append</span><span class="op">(</span>cmdArgs<span class="op">,</span> closureID<span class="op">)</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="rpc-calls" data-number="0.4.10.5">
<h4 data-number="1.4.10.5"><span class="header-section-number">1.4.10.5</span> RPC Calls</h4>
<p>As mentioned earlier, on the caller’s side, a placeholder struct
representing the callee’s available RPCs is provided to the registry.
Once the registry is linked to a connection, the placeholder struct’s
methods are iterated over and the signatures are validated for
compatibility with Dudirekta’s limitations. They are then implemented
using and set using reflection:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Iterating over the fields of the struct</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="op">:=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> remote<span class="op">.</span>NumField<span class="op">();</span> i<span class="op">++</span> <span class="op">{</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    functionField <span class="op">:=</span> remote<span class="op">.</span>Type<span class="op">().</span>Field<span class="op">(</span>i<span class="op">)</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>    functionType <span class="op">:=</span> functionField<span class="op">.</span>Type</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Validating that the requirements for the return values are met</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> functionType<span class="op">.</span>NumOut<span class="op">()</span> <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">||</span> functionType<span class="op">.</span>NumOut<span class="op">()</span> <span class="op">&gt;</span> <span class="dv">2</span> <span class="op">{</span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ErrInvalidReturn</span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Validating that the requirements for the arguments are met</span></span>
<span id="cb78-14"><a href="#cb78-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> functionType<span class="op">.</span>NumIn<span class="op">()</span> <span class="op">&lt;</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb78-15"><a href="#cb78-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ErrInvalidArgs</span>
<span id="cb78-16"><a href="#cb78-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb78-17"><a href="#cb78-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb78-18"><a href="#cb78-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-19"><a href="#cb78-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Using reflection to set the method&#39;s implementations</span></span>
<span id="cb78-20"><a href="#cb78-20" aria-hidden="true" tabindex="-1"></a>    remote<span class="op">.</span></span>
<span id="cb78-21"><a href="#cb78-21" aria-hidden="true" tabindex="-1"></a>        FieldByName<span class="op">(</span>functionField<span class="op">.</span>Name<span class="op">).</span></span>
<span id="cb78-22"><a href="#cb78-22" aria-hidden="true" tabindex="-1"></a>        Set<span class="op">(</span>r<span class="op">.</span>makeRPC<span class="op">(</span> <span class="co">// Creating the actual RPC implementation</span></span>
<span id="cb78-23"><a href="#cb78-23" aria-hidden="true" tabindex="-1"></a>            functionField<span class="op">.</span>Name<span class="op">,</span></span>
<span id="cb78-24"><a href="#cb78-24" aria-hidden="true" tabindex="-1"></a>            functionType<span class="op">,</span></span>
<span id="cb78-25"><a href="#cb78-25" aria-hidden="true" tabindex="-1"></a>            errs<span class="op">,</span></span>
<span id="cb78-26"><a href="#cb78-26" aria-hidden="true" tabindex="-1"></a>            conn<span class="op">,</span></span>
<span id="cb78-27"><a href="#cb78-27" aria-hidden="true" tabindex="-1"></a>            responseResolver<span class="op">,</span></span>
<span id="cb78-28"><a href="#cb78-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">))</span></span>
<span id="cb78-29"><a href="#cb78-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>These implementations simply marshal and unmarshal the function calls
into Dudirekta’s JSONL protocol upon being called, effectively
functioning as transparent proxies to the remote implementations; it is
at this point that unique call IDs are generated in order to be able to
support concurrent RPCs:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Creating the implementation method</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>reflect<span class="op">.</span>MakeFunc<span class="op">(</span>functionType<span class="op">,</span> <span class="kw">func</span><span class="op">(</span>args <span class="op">[]</span>reflect<span class="op">.</span>Value<span class="op">)</span> <span class="op">(</span>results <span class="op">[]</span>reflect<span class="op">.</span>Value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Generating a unique call ID</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>        callID <span class="op">:=</span> uuid<span class="op">.</span>NewString<span class="op">()</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>        cmdArgs <span class="op">:=</span> <span class="op">[]</span>any<span class="op">{}</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i<span class="op">,</span> arg <span class="op">:=</span> <span class="kw">range</span> args <span class="op">{</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Collecting the function arguments</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Marshalling the JSONL for the call</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>        b<span class="op">,</span> err <span class="op">:=</span> json<span class="op">.</span>Marshal<span class="op">(</span>cmd<span class="op">)</span></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Writing the JSONL to the remote</span></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>        conn<span class="op">.</span>Write<span class="op">(</span>b<span class="op">)</span></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a><span class="op">})</span></span></code></pre></div>
<p>Once the remote has responded with a message containing the unique
call ID, it unmarshals the return values, and returns from the
implemented method:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Spawning a new goroutine to handle the RPC return values</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>res <span class="op">:=</span> <span class="bu">make</span><span class="op">(</span><span class="kw">chan</span> response<span class="op">)</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="cf">go</span> <span class="kw">func</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">{</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Waiting for a message with the correct call ID to be received over a broadcaster channel</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>        msg <span class="op">:=</span> <span class="op">&lt;-</span>l<span class="op">.</span>Ch<span class="op">()</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> msg<span class="op">.</span>id <span class="op">==</span> callID <span class="op">{</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>            res <span class="op">&lt;-</span> msg</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a><span class="op">}()</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Receiving the raw return values</span></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>rawReturnValue <span class="op">:=</span> <span class="op">&lt;-</span>res<span class="op">:</span></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a><span class="co">// Unmarshalling, validating and returning the return values</span></span></code></pre></div>
<p>Closures are implemented similarly to this. If a closure is provided
as a function argument, instead of marshing the argument and sending it
as JSONL, the function is implemented by creating a “proxy” closure that
calls the remote <code>CallClosure</code> RPC, while reusing the same
marshalling/unmarshalling logic as regular RPCs. Calling this virtual
<code>CallClosure</code> RPC is possible from both the client and the
server because the protocol is bi-directional:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="co">// If an argument is a function instead of a JSON-serializable value, handle it differently</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> functionType<span class="op">.</span>Kind<span class="op">()</span> <span class="op">==</span> reflect<span class="op">.</span>Func <span class="op">{</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a closure proxy</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    arg <span class="op">:=</span> reflect<span class="op">.</span>MakeFunc<span class="op">(</span>functionType<span class="op">,</span> <span class="kw">func</span><span class="op">(</span>args <span class="op">[]</span>reflect<span class="op">.</span>Value<span class="op">)</span> <span class="op">(</span>results <span class="op">[]</span>reflect<span class="op">.</span>Value<span class="op">)</span> <span class="op">{</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// A reference to the virtual `CallClosure` RPC</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>        rpc <span class="op">:=</span> r<span class="op">.</span>makeRPC<span class="op">(</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;CallClosure&quot;</span><span class="op">,</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">// ...</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">)</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Continues with the same marshalling logic as regular function calls, then calls the virtual `CallClosure` RPC on the remote</span></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">})</span></span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="adapter-for-mounts-and-migrations" data-number="0.4.10.6">
<h4 data-number="1.4.10.6"><span class="header-section-number">1.4.10.6</span> Adapter for Mounts and
Migrations</h4>
<p>As mentioned earlier, Dudirekta has a few limitations when it comes
to the RPC signatures that are supported. This means that mount or
migration backends can’t be provided directly to the registry and need
to be wrapped using an adapter. To not have to duplicate this
translation for the different backends, a generic adapter between the
Dudirekta API and the <code>go-nbd</code> backend (as well as the)
interfaces exists:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> NewRPCBackend<span class="op">(</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    ctx context<span class="op">.</span>Context<span class="op">,</span> <span class="co">// Global context to be used for Dudirekta calls</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>    remote <span class="op">*</span>services<span class="op">.</span>BackendRemote<span class="op">,</span> <span class="co">// Dudirekta placeholder struct that is implemented by the registry</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="op">)</span> <span class="op">*</span>RPCBackend <span class="op">{</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>RPCBackend<span class="op">{</span>ctx<span class="op">,</span> remote<span class="op">}</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>RPCBackend<span class="op">)</span> ReadAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calling the RPC</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>    r<span class="op">,</span> err <span class="op">:=</span> b<span class="op">.</span>remote<span class="op">.</span>ReadAt<span class="op">(</span>b<span class="op">.</span>ctx<span class="op">,</span> <span class="bu">len</span><span class="op">(</span>p<span class="op">),</span> off<span class="op">)</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> err <span class="op">!=</span> <span class="ot">nil</span> <span class="op">{</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> err</span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Making the result compatible with the `go-nbd` backend interface</span></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> r<span class="op">.</span>N</span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">copy</span><span class="op">(</span>p<span class="op">,</span> r<span class="op">.</span>P<span class="op">)</span></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a><span class="co">// Same for all other mount/migration API methods</span></span></code></pre></div>
</section>
</section>
<section id="connection-pooling-with-grpc" data-number="0.4.11">
<h3 data-number="1.4.11"><span class="header-section-number">1.4.11</span> Connection Pooling with
gRPC</h3>
<p>While the dudirekta RPC implementation serves as a good reference
implementation of how RPC backends work, it has issues with scalability,
as is evident from the results section. This is mostly the case because
of it’s JSONL-based wire format, which, while simply and easy to
analyize, is quite slow to marshal and unmarshal. The bi-directional
RPCs do also come at a cost, since they prevent an effective use of
connection pooling; since a client <code>dial</code>ing the server
multiple times would mean that server could not reference multiple
client connections as one composite client, it would not be able to
differentiate two client connections from two separate clients. While
implementing a future pooling mechanism based on a client ID is possible
in the future, bi-directional RPCs can also be completely avoided
entirely by implementing the pull- instead of push-based pre-copy
solution described earlier where the destination host keeps track of the
pull progress, effectively making unary RPC support the only requirement
for a RPC framework.</p>
<p>Thanks to this narrower scope of requirements, alternative RPC
frameworks can be used that do not have this limitation to their
scalability. One such popular framework is gRPC, a high-performance
system based on protocol buffers which is based on code generation and
protocol buffers instead of reflection and JSONL. Thanks to it’s support
for unary RPCs, this protocol also supports connection pooling (which
removes Dudirekta’s main bottleneck) and is available in more language
ecosystems (whereas Dudirekta currently only supports Go and
TypeScript), making it possible to port the mount and migration APIs to
other languages with wire protocol compatibility in the future. In order
to implement the backend and seeder APIs for gRPC, they are defined in
the <code>proto3</code> DSL:</p>
<pre class="proto3"><code>// Fully-qualified package name
package com.pojtinger.felicitas.r3map.migration.v1;
// ...

// RPCs that are being provided, in this case for the migration API
service Seeder {
  rpc ReadAt(ReadAtArgs) returns (ReadAtReply) {};
  rpc Size(SizeArgs) returns (SizeReply) {};
  rpc Track(TrackArgs) returns (TrackReply) {};
  rpc Sync(SyncArgs) returns (SyncReply) {};
  rpc Close(CloseArgs) returns (CloseReply) {};
}

// Message definition for the `ReadAt` RPC
message ReadAtArgs {
  int32 Length = 1;
  int64 Off = 2;
}
// ... Rest of the message definitions</code></pre>
<p>After generating the gRPC bindings from this DSL, the generated
interface is implemented by using the Dudirekta RPC system’s
implementation struct as the abstract representation for the mount and
migration gRPC adapters respectively, in order to reduce
duplication:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> SeederGrpc <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    v1<span class="op">.</span>UnimplementedSeederServer <span class="co">// Generated gRPC interface</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    svc <span class="op">*</span>Seeder <span class="co">// Dudirekta RPC implementation</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>SeederGrpc<span class="op">)</span> ReadAt<span class="op">(</span>ctx context<span class="op">.</span>Context<span class="op">,</span> args <span class="op">*</span>v1<span class="op">.</span>ReadAtArgs<span class="op">)</span> <span class="op">(*</span>v1<span class="op">.</span>ReadAtReply<span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Forwarding the call to the service implementation from Dudirekta</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>    res<span class="op">,</span> err <span class="op">:=</span> s<span class="op">.</span>svc<span class="op">.</span>ReadAt<span class="op">(</span>ctx<span class="op">,</span> <span class="dt">int</span><span class="op">(</span>args<span class="op">.</span>GetLength<span class="op">()),</span> args<span class="op">.</span>GetOff<span class="op">())</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Making the result compatible with gRPC&#39;s generated interface</span></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>v1<span class="op">.</span>ReadAtReply<span class="op">{</span></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>        N<span class="op">:</span> <span class="dt">int32</span><span class="op">(</span>res<span class="op">.</span>N<span class="op">),</span></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>        P<span class="op">:</span> res<span class="op">.</span>P<span class="op">,</span></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span> <span class="ot">nil</span></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a><span class="co">// ... Same for the rest of the RPCs</span></span></code></pre></div>
</section>
<section id="optimizing-throughput-with-frpc" data-number="0.4.12">
<h3 data-number="1.4.12"><span class="header-section-number">1.4.12</span> Optimizing Throughput with
fRPC</h3>
<p>While gRPC tends to perform better than Dudirekta due to it’s support
for connection pooling and more efficient binary serialization, it can
be improved upon. This is particularly true for protocol buffers, which,
while being faster than JSON, have issues with encoding large chunks of
data, and can become a real bottleneck with large chunk sizes:</p>
<p>TODO: Add graphic from
https://frpc.io/performance/grpc-benchmarks</p>
<p>fRPC<span class="citation" data-cites="loopholelabs2023frpc">[50]</span>, a drop-in replacement for
gRPC, can improve upon this by switching out the serialization layer
with the faster Polyglot<span class="citation" data-cites="loopholelabs2023polyglot">[51]</span> library and a custom
transport layer. It also uses the proto3 DSL and the same code
generation framework as gRPC, which makes it easy to switch to by simply
re-generating the code from the DSL. The implementation of the fRPC
adapter functions in a very similar way as the gRPC adapter:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> SeederFrpc <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>    svc <span class="op">*</span>Seeder <span class="co">// Dudirekta RPC implementation</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>s <span class="op">*</span>SeederFrpc<span class="op">)</span> ReadAt<span class="op">(</span>ctx context<span class="op">.</span>Context<span class="op">,</span> args <span class="op">*</span>v1<span class="op">.</span>ComPojtingerFelicitasR3MapMigrationV1ReadAtArgs<span class="op">)</span> <span class="op">(*</span>v1<span class="op">.</span>ComPojtingerFelicitasR3MapMigrationV1ReadAtReply<span class="op">,</span> <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Forwarding the call to the service implementation from Dudirekta</span></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>    res<span class="op">,</span> err <span class="op">:=</span> s<span class="op">.</span>svc<span class="op">.</span>ReadAt<span class="op">(</span>ctx<span class="op">,</span> <span class="dt">int</span><span class="op">(</span>args<span class="op">.</span>Length<span class="op">),</span> args<span class="op">.</span>Off<span class="op">)</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Making the result compatible with fRPC&#39;s generated interface</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>v1<span class="op">.</span>ComPojtingerFelicitasR3MapMigrationV1ReadAtReply<span class="op">{</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a>        N<span class="op">:</span> <span class="dt">int32</span><span class="op">(</span>res<span class="op">.</span>N<span class="op">),</span></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>        P<span class="op">:</span> res<span class="op">.</span>P<span class="op">,</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span> <span class="ot">nil</span></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a><span class="co">// ... Same for the rest of the RPCs</span></span></code></pre></div>
</section>
</section>
<section id="results" data-number="0.5">
<h2 data-number="1.5"><span class="header-section-number">1.5</span>
Results</h2>
<p>TODO: Add results</p>
</section>
<section id="discussion" data-number="0.6">
<h2 data-number="1.6"><span class="header-section-number">1.6</span>
Discussion</h2>
<p>TODO: Add discussion once we have the results</p>
<section id="remote-swap-with-ram-dl" data-number="0.6.1">
<h3 data-number="1.6.1"><span class="header-section-number">1.6.1</span>
Remote Swap with <code>ram-dl</code></h3>
<p><code>ram-dl</code><span class="citation" data-cites="pojtinger2023ramdl">[52]</span> is an experimental tech demo
built to demonstrate how r3map can be used. It uses the fRPC mount
backend to expand local system memory, enabling a variety of usecases
such as mounting a remote system’s RAM locally or easily inspecting a
remote system’s memory contents.</p>
<p>In is based on the direct mount API and uses <code>mkswap</code>,
<code>swapon</code> and <code>swapoff</code> to enable the Kernel to
page out to the mount’s block device:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Create a swap partition on the block device</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>exec<span class="op">.</span>Command<span class="op">(</span><span class="st">&quot;mkswap&quot;</span><span class="op">,</span> devPath<span class="op">).</span>CombinedOutput<span class="op">()</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Enable paging and swapping to the block device</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>exec<span class="op">.</span>Command<span class="op">(</span><span class="st">&quot;swapon&quot;</span><span class="op">,</span> devPath<span class="op">).</span>CombinedOutput<span class="op">()</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="co">// When the mount is stopped, stop paging and swapping to the block device</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a><span class="cf">defer</span> exec<span class="op">.</span>Command<span class="op">(</span><span class="st">&quot;swapoff&quot;</span><span class="op">,</span> devPath<span class="op">).</span>CombinedOutput<span class="op">()</span></span></code></pre></div>
<p><code>ram-dl</code> exposes two commands that achieve this. The
first, <code>ram-ul</code> exposes RAM by exposing a memory, file or
directory-based backend using a fRPC endpoint. <code>ram-dl</code>
itself then connects to this endpoint, starts a direct mount and sets
the block device up for swapping. While this system is intended mostly
as a tech demo and, due to latency and throughput limitations, is not
intended for critical deployments, it does show how simple using the
r3map API can be be, as the entire project consistents of under 300
source lines of code, most of which is argument handling and boilerplate
around configuration.</p>
</section>
<section id="mapping-tape-into-memory-with-tapisk" data-number="0.6.2">
<h3 data-number="1.6.2"><span class="header-section-number">1.6.2</span>
Mapping Tape Into Memory With <code>tapisk</code></h3>
<section id="overview-6" data-number="0.6.2.1">
<h4 data-number="1.6.2.1"><span class="header-section-number">1.6.2.1</span> Overview</h4>
<p><code>tapisk</code><span class="citation" data-cites="pojtinger2023tapisk">[53]</span> is a tool that exposes a
tape drive as a block device. While seemingly unrelated to memory
synchronization, it does serve as an interesting usecase due to the
similarities to STFS (mentioned earlier in the FUSE section), which
exposed a tape drive as a file system, and serves as an interesting
example for how even seemingly incompatible backends for can be used to
store and synchronize memory.</p>
<p>Using a tape drive as such a backend is challenging, since they are
designed for linear access and don’t support random reads, while block
devices need support for reading and writing to arbitrary location.
Tapes also have very high read/write latencies due to slow seek speeds,
taking up to more than a minute depending on the offset of the tape that
is being accessed. Due to the modularity of r3map’s managed mount API
however, it is possible to work around these issues, and make the tape
appear as a random-access block device.</p>
</section>
<section id="implementation-1" data-number="0.6.2.2">
<h4 data-number="1.6.2.2"><span class="header-section-number">1.6.2.2</span> Implementation</h4>
<p>To achieve this, the background writes and reads provided by the
managed mount API can be used. Using these, a faster storage backend
(i.e. the disk) can be used as a caching layer, although the concurrent
push/pull system can’t be used due to tapes only supporting synchronous
read/write operations. By using the managed mount, writes are
de-duplicated and both read and write operations can become
asynchronous, since both happen on the fast local backend first, and the
background sync system them handles either periodic writebacks to the
tape for write operations or reading a chunk from the tape if it is
missing from the cache.</p>
<p>Since chunking works differently for tapes than for block devices,
and tapes are append-only devices where overwriting a section prior to
the end would result in all following data being overwritten, too, an
index must be used to simulate the offsets of the block device locations
to their physical location on the tape, which the <code>bbolt</code>
database is used for. In order to make non-aligned reads and writes to
the tape possible, the existing <code>ArbitraryReadWriter</code> system
can be used. When a chunk is then requested to be read,
<code>tapisk</code> looks up the physical tape record for the requested
offset, and uses the accelerated <code>MTSEEK</code> ioctl to seek to
the matching record on the tape, after which the chunk is read from the
tape into memory:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>TapeBackend<span class="op">)</span> ReadAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculating the block for the offset</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    block <span class="op">:=</span> <span class="dt">uint64</span><span class="op">(</span>off<span class="op">)</span> <span class="op">/</span> b<span class="op">.</span>blocksize</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Getting the physical record on the tape from the index</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>    location<span class="op">,</span> err <span class="op">:=</span> b<span class="op">.</span>index<span class="op">.</span>GetLocation<span class="op">(</span>block<span class="op">)</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb87-8"><a href="#cb87-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-9"><a href="#cb87-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Creating the seek operation</span></span>
<span id="cb87-10"><a href="#cb87-10" aria-hidden="true" tabindex="-1"></a>    mtop <span class="op">:=</span> <span class="op">&amp;</span>ioctl<span class="op">.</span>Mtop<span class="op">{}</span></span>
<span id="cb87-11"><a href="#cb87-11" aria-hidden="true" tabindex="-1"></a>    mtop<span class="op">.</span>SetOp<span class="op">(</span>ioctl<span class="op">.</span>MTSEEK<span class="op">)</span></span>
<span id="cb87-12"><a href="#cb87-12" aria-hidden="true" tabindex="-1"></a>    mtop<span class="op">.</span>SetCount<span class="op">(</span>location<span class="op">)</span></span>
<span id="cb87-13"><a href="#cb87-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-14"><a href="#cb87-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Seeking to the record</span></span>
<span id="cb87-15"><a href="#cb87-15" aria-hidden="true" tabindex="-1"></a>    syscall<span class="op">.</span>Syscall<span class="op">(</span></span>
<span id="cb87-16"><a href="#cb87-16" aria-hidden="true" tabindex="-1"></a>        syscall<span class="op">.</span>SYS_IOCTL<span class="op">,</span></span>
<span id="cb87-17"><a href="#cb87-17" aria-hidden="true" tabindex="-1"></a>        drive<span class="op">.</span>Fd<span class="op">(),</span></span>
<span id="cb87-18"><a href="#cb87-18" aria-hidden="true" tabindex="-1"></a>        ioctl<span class="op">.</span>MTIOCTOP<span class="op">,</span></span>
<span id="cb87-19"><a href="#cb87-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">uintptr</span><span class="op">(</span>unsafe<span class="op">.</span>Pointer<span class="op">(</span>mtop<span class="op">)),</span></span>
<span id="cb87-20"><a href="#cb87-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">)</span></span>
<span id="cb87-21"><a href="#cb87-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb87-22"><a href="#cb87-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb87-23"><a href="#cb87-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Reading the chunk from the tape into memory</span></span>
<span id="cb87-24"><a href="#cb87-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b<span class="op">.</span>drive<span class="op">.</span>Read<span class="op">(</span>p<span class="op">)</span></span>
<span id="cb87-25"><a href="#cb87-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Conversely, in order to write a chunk to the tape,
<code>tapisk</code> seeks to the end of the tape (unless the last
operation was a write already, in which case the tape must be at the end
already). Once the seek has completed, the current physical record is
requested from the tape drive, and stored as the record for the block
that is to be written in the index, after which the chunk is written to
the tape. This effectively makes it possible to overwrite existing
chunks despite the tape being append-only, since subsequent writes to
the same chunk result result in the changes being written to the end of
the file with the index referencing the new physical location, but does
come at the cost of requiring defragmentation to clean up prior
iterations of chunks:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="op">(</span>b <span class="op">*</span>TapeBackend<span class="op">)</span> WriteAt<span class="op">(</span>p <span class="op">[]</span><span class="dt">byte</span><span class="op">,</span> off <span class="dt">int64</span><span class="op">)</span> <span class="op">(</span>n <span class="dt">int</span><span class="op">,</span> err <span class="dt">error</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculating the block for the offset</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    block <span class="op">:=</span> <span class="dt">uint64</span><span class="op">(</span>off<span class="op">)</span> <span class="op">/</span> b<span class="op">.</span>blocksize</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Seek to the end of the tape, unless the last operation was a write</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> b<span class="op">.</span>lastOpWasRead <span class="op">{</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>        mtop <span class="op">:=</span> <span class="op">&amp;</span>ioctl<span class="op">.</span>Mtop<span class="op">{}</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>        mtop<span class="op">.</span>SetOp<span class="op">(</span>ioctl<span class="op">.</span>MTEOM<span class="op">)</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>        mtop<span class="op">.</span>SetCount<span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>        syscall<span class="op">.</span>Syscall<span class="op">(</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>            syscall<span class="op">.</span>SYS_IOCTL<span class="op">,</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>            drive<span class="op">.</span>Fd<span class="op">(),</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>            ioctl<span class="op">.</span>MTIOCTOP<span class="op">,</span></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>            <span class="dt">uintptr</span><span class="op">(</span>unsafe<span class="op">.</span>Pointer<span class="op">(</span>mtop<span class="op">)),</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">)</span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get the current physical record</span></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>    curr<span class="op">,</span> err <span class="op">:=</span> b<span class="op">.</span>tell<span class="op">(</span>b<span class="op">.</span>drive<span class="op">)</span></span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Mapping the physical record to the block that is being written</span></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>index<span class="op">.</span>SetLocation<span class="op">(</span>block<span class="op">,</span> curr<span class="op">)</span></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Writing the chunk to the tape</span></span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>drive<span class="op">.</span>Write<span class="op">(</span>p<span class="op">)</span></span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="evaluation" data-number="0.6.2.3">
<h4 data-number="1.6.2.3"><span class="header-section-number">1.6.2.3</span> Evaluation</h4>
<p><code>tapisk</code> is a unique application of r3map’s technology,
and shows how flexible it is.By using this index, the effectively
becomes tape a standard <code>ReadWriterAt</code> stage (and
<code>go-nbd</code> backend) with support for aligned-reads in the same
way as the file or directory backends, and thanks to r3map’s pipeline
design, the regular chunking system could be reused, unlike in STFS were
it had to be built from scratch. By re-using the universal RPC backend
introduced earlier, which can give remote access to any
<code>go-nbd</code> backend over a RPC library like Dudirekta, gRPC or
fRPC, it is also possible to access a remote tape this way, i.e. to map
a remote tape library robot’s drive to a system over the network.</p>
<p>Being able to map a tape into memory without having to read the
entire contents first can have a variety of usecases. Tapes can store a
large amount of data, in the case of LTO-9, up to 18TB on a single
tape<span class="citation" data-cites="lto2020gen9">[54]</span>; being
able to access such a large amount of data directly in memory, instead
of having to work with tooling like <code>tar</code>, can significantly
improve developer experience. In addition to making it much easier to
access tape drives, <code>tapisk</code> can also serve as a replacement
for LTFS. LTFS is a custom file system implemented as a kernel module,
which allows for mounting a tape. If a <code>tapisk</code>-provided
block device is formatted with a filesystem such as EXT4 or Btrfs, it
can also be mounted locally, allowing the tape to be mounted as a file
system as well, with the added benefit of also being able to support any
filesystem that supports block devices as their backend. Compared to the
LTFS approach, this results in a much more maintainable project; while
LTFS is tens of thousands of kernel-level source lines of code,
<code>tapisk</code> achieves effectively the same usecase with just
under 350.</p>
</section>
</section>
<section id="improving-cloud-storage-clients" data-number="0.6.3">
<h3 data-number="1.6.3"><span class="header-section-number">1.6.3</span>
Improving Cloud Storage Clients</h3>
<section id="existing-solutions" data-number="0.6.3.1">
<h4 data-number="1.6.3.1"><span class="header-section-number">1.6.3.1</span> Existing Solutions</h4>
<p>r3map can also be used to create mountable remote filesystems with
unique advantages over existing solutions. Currently, there are two main
approaches to implementing cloud storage clients. Dropbox and Nextcloud
are examples of a system that listens to file changes on a folder and
synchronizes files as changes are detected, similarly to the file-based
memory region synchronization approach discussed earlier. The big
drawback of this approach is that everything that should be available
needs to be stored locally; if a lot of data is stored in the cloud
drive, it is common to only choose to synchronize a certain set of data
to the local host, as there is no way to dynamically download files as
they are being accessed. Read and write operations on such systems are
however very efficient, since the system’s file system is used and any
changes are written to/from this file system asynchronously by the
synchronization client. This approach also makes offline availability
easy, as files that have been synchronized to the local system stay
available even if network connectivity has been lost.</p>
<p>The other currently used option is to use a FUSE,
i.e. <code>s3fs</code><span class="citation" data-cites="gaul2023s3fs">[23]</span>, which allows for files to be
fetched on demand, but comes with a heavy performance penalty. This is
the case because most implementations, if a write or read request is
sent from the kernel to the FUSE, remote writes or reads happen directly
over the network, which makes this approach very sensitive to networks
with a high RTT. Offline usage is also usually not possible with a
FUSE-based approach, and features such as <code>inotify</code>, symlinks
etc. are hard to implement, leaving two imperfect solutions to
implementing a cloud storage client.</p>
</section>
<section id="hybrid-approach" data-number="0.6.3.2">
<h4 data-number="1.6.3.2"><span class="header-section-number">1.6.3.2</span> Hybrid Approach</h4>
<p>Using r3map makes it possible to get the benefits of both approaches
by not having to download any files in advance and also being able to
write back changes asynchronously, as well as being able to use almost
any existing file system with it’s complete feature set. Files can also
be downloaded preemptively to allow for offline access, just like with
the approach that listens to file changes in a directory.</p>
<p>This is possible by once again using the managed mount API. The block
device is formatted using a valid filesystem, i.e. EXT4, and then
mounted on the host. By configuring the background pull system’s workers
and pull priority function, it possible to also download files for
offline access, and files have not yet been downloaded to the local
system can be pulled from the remote backend as their chunks are being
accessed. If a chunk is available locally, reads are also much faster
than their would be with a FUSE implementation, and since writes are
made to the local backend first, and then being synchronized back to the
remote using the remote push system, the same applies to the writes too.
Furthermore, by using the migration API, it is possible to migrate the
file system between two hosts in a highly efficient way.</p>
<p>By combining the advantages of both approaches into a hybrid one, it
is possible to bridge the gap between them, showing that memory
synchronization technology like r3map can be used to not only
synchronize memory regions, but other state too, including disks.</p>
</section>
</section>
<section id="universal-database-media-and-asset-streaming" data-number="0.6.4">
<h3 data-number="1.6.4"><span class="header-section-number">1.6.4</span>
Universal Database, Media and Asset Streaming</h3>
<section id="streaming-access-to-remote-databases" data-number="0.6.4.1">
<h4 data-number="1.6.4.1"><span class="header-section-number">1.6.4.1</span> Streaming Access to Remote
Databases</h4>
<p>Another usecase that r3map can be used for is accessing a remote
database locally. While using a database backend (such as the Cassandra
backend introduced earlier) is one option of storing the chunk, this use
case is particularly interesting for file-based databases like SQLite
that don’t define a wire protocol. Using r3map, instead of having to
download an entire SQLite database before being able to use it, it can
instead be mounted with the mount API, with then fetches the necessary
offsets from a remote backend storing the database as their are being
accessed. For most queries, not all data in a database is required,
especially if indexes are used; this makes it possible to potentially
reduce the amount of transfered data by streaming in only what is
required.</p>
<p>Since reads are cached using the local backend with the managed mount
API, only the first read should potentially have a performance impact
(if it has not been pulled first by the background pull system);
similarly so, since writes are written to the local backend first, and
then asynchronously written back, the same applies to them as well.
Moreover, if the location of i.e. indexes within the SQLite database is
known, a pull heuristic can be specified to fetch these first to speed
up initial queries. Thanks to the managed mount API providing a standard
block device, no changes to SQLite are be required in order for it to
support such streaming access; the SQLite file could simply be stored on
a mounted file system provided by the mount’s block device.</p>
</section>
<section id="making-arbitrary-file-formats-streamable" data-number="0.6.4.2">
<h4 data-number="1.6.4.2"><span class="header-section-number">1.6.4.2</span> Making Arbitrary File
Formats Streamable</h4>
<p>In addition to making databases streamable, r3map can also be used to
access files in formats that usually don’t support being accessed before
they are fully available locally possible. One such format is MP4;
usually, if a user downloads a MP4 file, they can’t start playback
before the file is available locally completely. This is because MP4
typically stores metadata at the end of the file:</p>
<p>TODO: Add graphic with MP4 metadata</p>
<p>The reason for this being stored at the end is usually that the
parameters required for this metadata requires encoding the video first.
This results in a scenario where, assuming that the file is downloaded
from the first to the last offset, the client needs to wait for the file
to be completely accessible locally before playing it. While MP4 and
other formats supports ways to encode such metadata in the beginning or
once every few chunks in order to make them streamable, this is not the
case for already existing files and comes with other tradeoffs. By using
r3map however, the pull heuristic function can be used to immediately
pre-fetch the metadata; the rest of the chunks can then be fetched
either by using the background pull system and/or ad-hoc as they are
being accessed.</p>
<p>Similarly to the approach used to stream in remote databases, this
does not require any changes to the media player being used, since the
block device providing the ressource can simply be mounted as a file
system and thus be used transparently.</p>
</section>
<section id="streaming-app-and-game-assets" data-number="0.6.4.3">
<h4 data-number="1.6.4.3"><span class="header-section-number">1.6.4.3</span> Streaming App and Game
Assets</h4>
<p>Another streaming usecase relates to the in-place streaming of
assets. Usually, a game needs to be fully downloaded before it is
playable; for many modern AAA titles, this can be hundreds of gigabytes
of data, resulting in very long download times even on fast internet
connections. Usually however, not all assets need to be downloaded
before the game can be played; only some of them are, i.e. the launcher,
UI libraries or the first level’s assets. While theoritically it would
be possible to design a game engine in such a way that assets are only
fetched from a remote as they are being required, this would require
extensive changes to most engine’s architecture, and also be hard to
port back to existing titles; furthermore, current transparent solutions
that can fetch in assets (i.e. mounting a remote NBD drive or FUSE) are
unlikely to be viable solutions considering their high sensitivity to
network latency and the high network throughput required for streaming
in these assets.</p>
<p>By using the managed mount API to stream in the assets, the overhead
of such a solution can be reduced, without requiring changes to the game
or it’s engine. By using the background pull system, reads from chunks
that have already been pulled are almost as fast as native disk reads,
and by analyzing the access pattern of an existing game, a pull
heuristic function can be generated which preemptively pulls the game
assets that are loaded first, keeping latency spikes as low as possible.
By using the callbacks for monitoring the pull progress provided by the
managed mounts, the game can also be paused until a certain local chunk
availability is reached in order to prevent latency spikes from missing
assets that would need to be fetched directly from the remote, while
still allowing for faster startup times.</p>
<p>This concept is not limited to games however, and could also be
applied to launching any application. For many systems, completely
scanning a binary or script into memory isn’t required for it to start
execution; similarly to the situation of game engines, adding streaming
support would require changes to the interpreters or VMs, since they
don’t provide a streaming API out of the box aside from being able to
read files from the filesystem. With the managed mount API, this
existing interface can be reused to add streaming support to these
systems by simply pointing them to a filesystem provided by the mount’s
block device, or, if the interpreter/VM supports it,
<code>mmap</code>ing the block device directly and executing the
resulting memory region.</p>
</section>
</section>
<section id="universal-app-state-mounts-and-migrations" data-number="0.6.5">
<h3 data-number="1.6.5"><span class="header-section-number">1.6.5</span>
Universal App State Mounts and Migrations</h3>
<section id="modelling-state" data-number="0.6.5.1">
<h4 data-number="1.6.5.1"><span class="header-section-number">1.6.5.1</span> Modelling State</h4>
<p>Synchronization of app state is a fairly complex problem, and even
for simple scenarios, a custom protocol is built for simple apps. While
it possible to real-time databases like Firebase to synchronize some
application state, it and similar solutions to it are usually limited in
which data structures they can store and require specific APIs to
synchronize them. Usually, even for a simple migration of state between
two hosts, synchronization requires state to be manually marshalled,
sent over a network, received on a destination host, and unmarshalled.
This requires a complex synchronization protocol, and decisions such as
when to synchronize state and when to start pulling from the remote need
to be made manually, resulting in a database on a third host being used
even for simple migrations from one host to another. Almost all of these
data structures can ultimately be represented by a byte array; by
allocating them from a slice <code>mmap</code>ed by r3map, we can use
the managed mount, direct mount or migration APIs to implement a
universal way of both synchronization and migration of application
state, without having to implement a custom protocol.</p>
</section>
<section id="mounting-state" data-number="0.6.5.2">
<h4 data-number="1.6.5.2"><span class="header-section-number">1.6.5.2</span> Mounting State</h4>
<p>By allocating all structures on r3map’s provided <code>mmap</code>ed
byte slice, many interesting usecases become possible. For example, a
TODO app could use it as it’s backend. Once loaded, the app mounts the
TODO list as a byte slice from a remote server using the managed mount
API; since authentication is pluggable and i.e. a database backend like
Cassandra with a prefix for this user provides a way to do both
authentication and authorization, such an approach can scale fairly
well. Using the preemptive background pull system, when the user
connects, they can start streaming in the byte slice from the remote
server as the app is accessing it, but also pull the majority of the
required data first by using the pull heuristic function. If the TODO
list is modified by changing it in the <code>mmap</code>ed memory
region, the changes are asynchronously written back to the underlying
block device, and thus to the local backend, where the asynchronous
writebacks can sync them back to the remtote. If the local backend is
persistent, i.e. file-based, such a system can even survive network
outages.</p>
</section>
<section id="migrating-state" data-number="0.6.5.3">
<h4 data-number="1.6.5.3"><span class="header-section-number">1.6.5.3</span> Migrating State</h4>
<p>In addition to using managed mounts to access remotely stored
application state, migration of arbitrary app state also becomes a
posibility. If a user has a TODO app running on a host like their
smartphone, but wants to continue writing a task description on their
desktop system, they can migrate the app’s state directly and without a
third party/remote database by using r3map. For this usecase, the
migration API can be used. In order to optimize the migration, the
pre-copy phase can be started automatically, i.e. if the phone and
desktop are physically close to each other or in the same network; in
such a LAN migration case, the migration is be able to benefit from low
latencies and high throughputs. It is also possible to integrate the
migration API deeply with system events, i.e. by registering a service
that migrates applications off a system before a shutdown procedure
completes.</p>
</section>
<section id="migrating-virtual-machines" data-number="0.6.5.4">
<h4 data-number="1.6.5.4"><span class="header-section-number">1.6.5.4</span> Migrating Virtual
Machines</h4>
<p>It is important to note that there are a few limitations with
synchronizing and migrating an application’s internal stateful data
structures this way; locking is not handled by r3map and would need to
be done using a higher-level protocol; moreover, this assumes that the
in-memory representation of the data structure is consistent across all,
something which is not necessarily the case with programming languages
such as Go with multiple processor architectures being involved. While
projects such as Apache Arrow<span class="citation" data-cites="apache2023arrow">[55]</span> allow for application state to
represented in a language- and CPU architecture-independent way, this
comes with some of the same restrictions on which state can be
synchronized as with other solutions such as Firebase.</p>
<p>In order to keep the possibility of migrating arbitrary state, but
also allow for cross-architecture compatibility, VMs can be used.
Keeping with the TODO app example, if the resulting app is compiled to
Wasm, instead of having to allocate all memory that is to be
synchronized from the r3map-provided <code>mmap</code>ed byte slice, it
is possible to instead simply synchronize the Wasm VM’s linear memory as
a whole, which also allows storing the entire app’s state on a remote as
well as migrating an entire app. Similarly so, the app’s binary, mounted
WASI filesystems etc. could all be synchronized this way, too. Thanks to
the preemptive pull implementation outlined earlier, the VM startup and
device initialization can also be parallized to allow for shorter
latencies while resuming the VM.</p>
<p>This capability is not limited to Wasm VMs however; rather, it is
possible to add these features to almost any hypervisor or virtual
machine that supports mapping a application’s/virtual machine’s state to
a block device or memory region, essentially adding the capability to
suspend/resume and migrate any application in the same way that is
possible today over WAN, without requiring any or only minimal changes
to the applications themselves.</p>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-linux2023docs" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">T.
kernel development community, <span>“Quick start.”</span> <a href="https://www.kernel.org/doc/html/next/rust/quick-start.html" class="uri">https://www.kernel.org/doc/html/next/rust/quick-start.html</a>,
2023.</div>
</div>
<div id="ref-love2010linux" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">R.
Love, <em>Linux kernel development</em>, 3rd ed. Pearson Education,
Inc., 2010.</div>
</div>
<div id="ref-maurer2008professional" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">W.
Mauerer, <em>Professional linux kernel architecture</em>. Indianapolis,
IN: Wiley Publishing, Inc., 2008.</div>
</div>
<div id="ref-stevens2000advanced" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">W.
R. Stevens, <em>Advanced programming in the UNIX environment</em>.
Delhi: Addison Wesley Logman (Singapore) Pte Ltd., Indian Branch,
2000.</div>
</div>
<div id="ref-robbins2003unix" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[5] </div><div class="csl-right-inline">K.
A. Robbins and S. Robbins, <em>Unix™ systems programming: Communication,
concurrency, and threads</em>. Prentice Hall PTR, 2003.</div>
</div>
<div id="ref-stallings2010architecture" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[6] </div><div class="csl-right-inline">W.
Stallings, <em>Computer organization and architecture: Designing for
performance</em>. Upper Saddle River, New Jersey, 07458: Pearson
Education, Inc., 2010.</div>
</div>
<div id="ref-smith1982cache" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[7] </div><div class="csl-right-inline">A.
J. Smith, <span>“Cache memories,”</span> <em>ACM Comput. Surv.</em>,
vol. 14, no. 3, pp. 473–530, Sep. 1982, doi: <a href="https://doi.org/10.1145/356887.356892">10.1145/356887.356892</a>.</div>
</div>
<div id="ref-barr2021offline" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[8] </div><div class="csl-right-inline">J.
Barr, <span>“New - offline tape migration using AWS snowball
edge.”</span> <a href="https://aws.amazon.com/blogs/aws/new-offline-tape-migration-using-aws-snowball-edge/" class="uri">https://aws.amazon.com/blogs/aws/new-offline-tape-migration-using-aws-snowball-edge/</a>,
2021.</div>
</div>
<div id="ref-maruf2023memory" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[9] </div><div class="csl-right-inline">H.
A. Maruf and M. Chowdhury, <span>“Memory disaggregation: Advances and
open challenges.”</span> 2023.Available: <a href="https://arxiv.org/abs/2305.03943">https://arxiv.org/abs/2305.03943</a></div>
</div>
<div id="ref-bonwick1994slaballoc" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[10] </div><div class="csl-right-inline">J.
Bonwick, <span>“The slab allocator: An <span>Object-Caching</span>
kernel,”</span> Jun. 1994.Available: <a href="https://www.usenix.org/conference/usenix-summer-1994-technical-conference/slab-allocator-object-caching-kernel">https://www.usenix.org/conference/usenix-summer-1994-technical-conference/slab-allocator-object-caching-kernel</a></div>
</div>
<div id="ref-gorman2004linuxmem" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[11] </div><div class="csl-right-inline">M.
Gorman, <em>Understanding the linux virtual memory manager</em>. Upper
Saddle River, New Jersey 07458: Pearson Education, Inc. Publishing as
Prentice Hall Professional Technical Reference, 2004.</div>
</div>
<div id="ref-kernel2023suspend" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[12] </div><div class="csl-right-inline">T.
K. D. Community, <span>“Swap suspend,”</span> 2023. <a href="https://www.kernel.org/doc/html/latest/power/swsusp.html">https://www.kernel.org/doc/html/latest/power/swsusp.html</a>
(accessed Jul. 19, 2023).</div>
</div>
<div id="ref-silberschatz2018operating" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[13] </div><div class="csl-right-inline">A.
Silberschatz, P. B. Galvin, and G. Gagne, <em>Operating system
concepts</em>, 10th ed. Hoboken, NJ: Wiley, 2018.Available: <a href="https://lccn.loc.gov/2017043464">https://lccn.loc.gov/2017043464</a></div>
</div>
<div id="ref-choi2017mmap" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[14] </div><div class="csl-right-inline">J.
Choi, J. Kim, and H. Han, <span>“Efficient memory mapped file
<span>I/O</span> for <span>In-Memory</span> file systems,”</span> Jul.
2017.Available: <a href="https://www.usenix.org/conference/hotstorage17/program/presentation/choi">https://www.usenix.org/conference/hotstorage17/program/presentation/choi</a></div>
</div>
<div id="ref-prokop2010inotify" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[15] </div><div class="csl-right-inline">M.
Prokop, <span>“Inotify: Efficient, real-time linux file system event
monitoring,”</span> Apr. 2010. <a href="https://www.infoq.com/articles/inotify-linux-file-system-event-monitoring/">https://www.infoq.com/articles/inotify-linux-file-system-event-monitoring/</a></div>
</div>
<div id="ref-postel1981tcp" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[16] </div><div class="csl-right-inline"><span>“<span>Transmission Control
Protocol</span>.”</span> RFC 793; J. Postel, Sep. 1981. doi: <a href="https://doi.org/10.17487/RFC0793">10.17487/RFC0793</a>.</div>
</div>
<div id="ref-postel1980udp" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[17] </div><div class="csl-right-inline"><span>“<span>User Datagram
Protocol</span>.”</span> RFC 768; J. Postel, Aug. 1980. doi: <a href="https://doi.org/10.17487/RFC0768">10.17487/RFC0768</a>.</div>
</div>
<div id="ref-rfc2021quic" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[18] </div><div class="csl-right-inline">J.
Iyengar and M. Thomson, <span>“<span class="nocase">QUIC: A UDP-Based
Multiplexed and Secure Transport</span>.”</span> RFC 9000; RFC Editor,
May 2021. doi: <a href="https://doi.org/10.17487/RFC9000">10.17487/RFC9000</a>.</div>
</div>
<div id="ref-langley2017quic" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[19] </div><div class="csl-right-inline">A.
Langley <em>et al.</em>, <span>“The QUIC transport protocol: Design and
internet-scale deployment,”</span> in <em>Proceedings of the conference
of the ACM special interest group on data communication</em>, 2017, pp.
183–196. doi: <a href="https://doi.org/10.1145/3098822.3098842">10.1145/3098822.3098842</a>.</div>
</div>
<div id="ref-xiao2018rsync" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[20] </div><div class="csl-right-inline">H.
Xiao <em>et al.</em>, <span>“Towards web-based delta synchronization for
cloud storage services,”</span> in <em>16th USENIX conference on file
and storage technologies (FAST 18)</em>, Feb. 2018, pp.
155–168.Available: <a href="https://www.usenix.org/conference/fast18/presentation/xiao">https://www.usenix.org/conference/fast18/presentation/xiao</a></div>
</div>
<div id="ref-libfuse2020example" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[21] </div><div class="csl-right-inline">T.
libfuse authors, <span>“FUSE minimal example filesystem using high-level
API.”</span> <a href="https://github.com/libfuse/libfuse/blob/master/example/hello.c" class="uri">https://github.com/libfuse/libfuse/blob/master/example/hello.c</a>,
2020.</div>
</div>
<div id="ref-vangoor2017fuse" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[22] </div><div class="csl-right-inline">B.
K. R. Vangoor, V. Tarasov, and E. Zadok, <span>“To <span>FUSE</span> or
not to <span>FUSE</span>: Performance of <span>User-Space</span> file
systems,”</span> in <em>15th USENIX conference on file and storage
technologies (FAST 17)</em>, Feb. 2017, pp. 59–72.Available: <a href="https://www.usenix.org/conference/fast17/technical-sessions/presentation/vangoor">https://www.usenix.org/conference/fast17/technical-sessions/presentation/vangoor</a></div>
</div>
<div id="ref-gaul2023s3fs" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[23] </div><div class="csl-right-inline">A.
Gaul, T. Nakatani, and @rrizun, <span>“s3fs: FUSE-based file system
backed by amazon S3.”</span> <a href="https://github.com/s3fs-fuse/s3fs-fuse" class="uri">https://github.com/s3fs-fuse/s3fs-fuse</a>, 2023.</div>
</div>
<div id="ref-libfuse2022sshfs" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[24] </div><div class="csl-right-inline">T.
libfuse authors, <span>“SSHFS: A network filesystem client to connect to
SSH servers.”</span> <a href="https://github.com/libfuse/sshfs" class="uri">https://github.com/libfuse/sshfs</a>, 2022.</div>
</div>
<div id="ref-blake2023nbd" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[25] </div><div class="csl-right-inline">E.
Blake, W. Verhelst, and other NBD maintainers, <span>“The NBD
protocol.”</span> <a href="https://github.com/NetworkBlockDevice/nbd/blob/master/doc/proto.md" class="uri">https://github.com/NetworkBlockDevice/nbd/blob/master/doc/proto.md</a>,
Apr. 2023.</div>
</div>
<div id="ref-clements2013nbd" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[26] </div><div class="csl-right-inline">P.
Clements, <span>“[PATCH] nbd: Increase default and max request
sizes.”</span> <a href="https://lore.kernel.org/lkml/20130402194120.54043222C0@clements/" class="uri">https://lore.kernel.org/lkml/20130402194120.54043222C0@clements/</a>,
Apr. 02, 2013.</div>
</div>
<div id="ref-verhelst2023nbdclient" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[27] </div><div class="csl-right-inline">W.
Verhelst, <em>Nbd-client man page</em>. 2023.Available: <a href="https://manpages.ubuntu.com/manpages/lunar/en/man8/nbd-client.8.html">https://manpages.ubuntu.com/manpages/lunar/en/man8/nbd-client.8.html</a></div>
</div>
<div id="ref-he2016migration" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[28] </div><div class="csl-right-inline">S.
He, C. Hu, B. Shi, T. Wo, and B. Li, <span>“Optimizing virtual machine
live migration without shared storage in hybrid clouds,”</span> in
<em>2016 IEEE 18th international conference on high performance
computing and communications; IEEE 14th international conference on
smart city; IEEE 2nd international conference on data science and
systems (HPCC/SmartCity/DSS)</em>, 2016, pp. 921–928. doi: <a href="https://doi.org/10.1109/HPCC-SmartCity-DSS.2016.0132">10.1109/HPCC-SmartCity-DSS.2016.0132</a>.</div>
</div>
<div id="ref-baruchi2015workload" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[29] </div><div class="csl-right-inline">A.
Baruchi, E. Toshimi Midorikawa, and L. Matsumoto Sato, <span>“Reducing
virtual machine live migration overhead via workload analysis,”</span>
<em>IEEE Latin America Transactions</em>, vol. 13, no. 4, pp. 1178–1186,
2015, doi: <a href="https://doi.org/10.1109/TLA.2015.7106373">10.1109/TLA.2015.7106373</a>.</div>
</div>
<div id="ref-akidau2018streaming" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[30] </div><div class="csl-right-inline">T.
Akidau, S. Chernyak, and R. Lax, <em>Streaming systems</em>. Sebastopol,
CA: O’Reilly Media, Inc., 2018.</div>
</div>
<div id="ref-peek1994unix" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[31] </div><div class="csl-right-inline">J.
D. Peek, <em>UNIX power tools</em>. Sebastopol, CA; New York: O’Reilly
Associates; Bantam Books, 1994.</div>
</div>
<div id="ref-google2023grpc" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[32] </div><div class="csl-right-inline">gRPC Authors, <span>“Introduction to
gRPC.”</span> 2023.Available: <a href="https://grpc.io/docs/what-is-grpc/introduction/">https://grpc.io/docs/what-is-grpc/introduction/</a></div>
</div>
<div id="ref-redis2023introduction" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[33] </div><div class="csl-right-inline">Redis Ltd, <span>“Introduction to
redis.”</span> <a href="https://redis.io/docs/about/" class="uri">https://redis.io/docs/about/</a>, 2023.</div>
</div>
<div id="ref-redis2023pubsub" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[34] </div><div class="csl-right-inline">Redis Ltd, <span>“Redis pub/sub.”</span> <a href="https://redis.io/docs/interact/pubsub/" class="uri">https://redis.io/docs/interact/pubsub/</a>, 2023.</div>
</div>
<div id="ref-aws2023s3" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[35] </div><div class="csl-right-inline">Amazon Web Services, Inc, <span>“What is amazon
S3?”</span> <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html" class="uri">https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html</a>,
2023.</div>
</div>
<div id="ref-minio2023coreadmin" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[36] </div><div class="csl-right-inline">MinIO, Inc, <span>“Core administration
concepts.”</span> <a href="https://min.io/docs/minio/kubernetes/upstream/administration/concepts.html" class="uri">https://min.io/docs/minio/kubernetes/upstream/administration/concepts.html</a>,
2023.</div>
</div>
<div id="ref-lakshman2010cassandra" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[37] </div><div class="csl-right-inline">A.
Lakshman and P. Malik, <span>“Cassandra: A decentralized structured
storage system,”</span> <em>SIGOPS Oper. Syst. Rev.</em>, vol. 44, no.
2, pp. 35–40, Apr. 2010, doi: <a href="https://doi.org/10.1145/1773912.1773922">10.1145/1773912.1773922</a>.</div>
</div>
<div id="ref-grabowski2021scylladb" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[38] </div><div class="csl-right-inline">P.
Grabowski, J. Stasiewicz, and K. Baryla, <span>“Apache cassandra 4.0
performance benchmark: Comparing cassandra 4.0, cassandra 3.11 and
scylla open source 4.4,”</span> ScyllaDB Inc, 2021.Available: <a href="https://www.scylladb.com/wp-content/uploads/wp-apache-cassandra-4-performance-benchmark-3.pdf">https://www.scylladb.com/wp-content/uploads/wp-apache-cassandra-4-performance-benchmark-3.pdf</a></div>
</div>
<div id="ref-corbet2015linux43" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[39] </div><div class="csl-right-inline">J.
Corbet, <span>“4.3 merge window, part 2.”</span> <a href="https://lwn.net/Articles/656731/" class="uri">https://lwn.net/Articles/656731/</a>, 2015.Available: <a href="https://lwn.net/Articles/656731/">https://lwn.net/Articles/656731/</a></div>
</div>
<div id="ref-pojtinger2022stfstests" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[40] </div><div class="csl-right-inline">F.
Pojtinger, <span>“STFS file system unit tests.”</span> <a href="https://github.com/pojntfx/stfs/blob/main/pkg/fs/filesystem_test.go" class="uri">https://github.com/pojntfx/stfs/blob/main/pkg/fs/filesystem_test.go</a>,
2022.</div>
</div>
<div id="ref-francia2023afero" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[41] </div><div class="csl-right-inline">S.
Francia, <span>“Fs interface - afero: A FileSystem abstraction system
for go.”</span> <a href="https://pkg.go.dev/github.com/spf13/afero#Fs" class="uri">https://pkg.go.dev/github.com/spf13/afero#Fs</a>,
2023.</div>
</div>
<div id="ref-pojtinger2022stfs" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[42] </div><div class="csl-right-inline">F.
Pojtinger, <span>“<span class="nocase">STFS: Simple Tape File System, a
file system for tapes and tar files</span>.”</span> <a href="https://github.com/pojntfx/stfs" class="uri">https://github.com/pojntfx/stfs</a>, 2022.</div>
</div>
<div id="ref-waibel2022silefystem" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[43] </div><div class="csl-right-inline">J.
Waibel and F. Pojtinger, <span>“<span class="nocase">sile-fystem: A
generic FUSE implementation</span>.”</span> <a href="https://github.com/jakWai01/sile-fystem" class="uri">https://github.com/jakWai01/sile-fystem</a>, 2022.</div>
</div>
<div id="ref-grieger2015cgo" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[44] </div><div class="csl-right-inline">T.
Grieger, <span>“The cost and complexity of cgo.”</span> Dec.
2015.Available: <a href="https://www.cockroachlabs.com/blog/the-cost-and-complexity-of-cgo/">https://www.cockroachlabs.com/blog/the-cost-and-complexity-of-cgo/</a></div>
</div>
<div id="ref-pojtinger2023weron" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[45] </div><div class="csl-right-inline">F.
Pojtinger, <span>“Weron: Overlay networks based on WebRTC.”</span> <a href="https://github.com/pojntfx/weron" class="uri">https://github.com/pojntfx/weron</a>, 2023.</div>
</div>
<div id="ref-linux2023nbd" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[46] </div><div class="csl-right-inline">T.
L. K. Contributors, <span>“NBD kernel module in the linux kernel source
tree.”</span> <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/block/nbd.c#n2592" class="uri">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/block/nbd.c#n2592</a>,
2023.</div>
</div>
<div id="ref-aguilera2018remoteregions" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[47] </div><div class="csl-right-inline">M.
K. Aguilera <em>et al.</em>, <span>“Remote regions: A simple abstraction
for remote memory,”</span> in <em>Proceedings of the 2018 USENIX
conference on usenix annual technical conference</em>, 2018, pp.
775–787.</div>
</div>
<div id="ref-pojtinger2023dudirekta" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[48] </div><div class="csl-right-inline">F.
Pojtinger, <span>“Dudirekta: Transport-agnostic framework that allows
exposing and calling functions on both clients and servers.”</span> <a href="https://github.com/pojntfx/dudirekta" class="uri">https://github.com/pojntfx/dudirekta</a>, 2023.</div>
</div>
<div id="ref-pojtinger2023dudirektawebrtc" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[49] </div><div class="csl-right-inline">F.
Pojtinger, <span>“Dudirekta: WebRTC transport layer example.”</span> <a href="https://github.com/pojntfx/dudirekta/blob/main/cmd/dudirekta-example-webrtc-peer/main.go" class="uri">https://github.com/pojntfx/dudirekta/blob/main/cmd/dudirekta-example-webrtc-peer/main.go</a>,
2023.</div>
</div>
<div id="ref-loopholelabs2023frpc" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[50] </div><div class="csl-right-inline">L.
Labs, <span>“fRPC: A modern RPC framework designed for high performance
and stability.”</span> <a href="https://frpc.io/introduction" class="uri">https://frpc.io/introduction</a>, 2023.</div>
</div>
<div id="ref-loopholelabs2023polyglot" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[51] </div><div class="csl-right-inline">S.
Shivansh Vij, <span>“Polyglot: A high-performance serialization
framework used for encoding and decoding arbitrary data structures
across languages.”</span> <a href="https://github.com/loopholelabs/polyglot" class="uri">https://github.com/loopholelabs/polyglot</a>, 2023.</div>
</div>
<div id="ref-pojtinger2023ramdl" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[52] </div><div class="csl-right-inline">F.
Pojtinger, <span>“Ram-dl: A tool to download more RAM (yes,
seriously!).”</span> <a href="https://github.com/pojntfx/ram-dl" class="uri">https://github.com/pojntfx/ram-dl</a>, 2023.</div>
</div>
<div id="ref-pojtinger2023tapisk" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[53] </div><div class="csl-right-inline">F.
Pojtinger, <span>“Tapisk: Expose a tape drive as a block device.”</span>
<a href="https://github.com/pojntfx/tapisk" class="uri">https://github.com/pojntfx/tapisk</a>, 2023.</div>
</div>
<div id="ref-lto2020gen9" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[54] </div><div class="csl-right-inline">LTO Program, <span>“The LTO program releases
specifications for upcoming generation 9.”</span> <a href="https://www.lto.org/2020/09/the-lto-program-releases-specifications-for-upcoming-generation-9/" class="uri">https://www.lto.org/2020/09/the-lto-program-releases-specifications-for-upcoming-generation-9/</a>,
2020.</div>
</div>
<div id="ref-apache2023arrow" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">[55] </div><div class="csl-right-inline">T.
A. S. Foundation, <span>“Apache arrow website.”</span> 2023.Available:
<a href="https://arrow.apache.org/">https://arrow.apache.org/</a></div>
</div>
</div>
</section>
</section>
</section>
</body>
</html>
